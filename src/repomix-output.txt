This file is a merged representation of the entire codebase, combined into a single document by Repomix.
The content has been processed where content has been compressed (code blocks are separated by ⋮---- delimiter).

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Content has been compressed - code blocks are separated by ⋮---- delimiter
- Files are sorted by Git change count (files with more changes are at the bottom)

Additional Info:
----------------

================================================================
Directory Structure
================================================================
assets/
  sofie-logo.svg
background/
  api/
    parts.ts
    pieceManifests.ts
    pieces.ts
    playlists.ts
    rundowns.ts
    segments.ts
    settings.ts
  configManifest.ts
  coreHandler.ts
  db.ts
  index.ts
  interfaces.ts
  manifest.ts
  util.ts
components/
  rundown/
    PartEditor.vue
    PieceEditor.vue
    PieceList.vue
    RundownEditor.vue
    RundownFooter.vue
    RundownHeader.vue
    SegmentEditor.vue
    SegmentList.vue
  settings/
    AppSettings.vue
    PieceType.vue
    PieceTypes.vue
  AppHeader.vue
  PlaylistList.vue
router/
  index.ts
store/
  modules/
    playlists.ts
  index.ts
types/
  smpte-timecode.d.ts
util/
  fs.ts
  lib.ts
views/
  HomeView.vue
  PlaylistView.vue
  RundownView.vue
  SettingsView.vue
App.vue
background.ts
main.ts
preload.ts
shims-tsx.d.ts
shims-vue.d.ts

================================================================
Files
================================================================

================
File: assets/sofie-logo.svg
================
<svg enable-background="new 0 0 35 35" viewBox="0 0 35 35" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><linearGradient id="a"><stop offset="0" stop-color="#9ccdff" stop-opacity=".5"/><stop offset="1" stop-color="#5ec1ff"/></linearGradient><linearGradient id="b" gradientUnits="userSpaceOnUse" x1="15.38" x2="28.264" xlink:href="#a" y1="2.078" y2="2.078"/><linearGradient id="c" gradientUnits="userSpaceOnUse" x1="11.921" x2="31.045" xlink:href="#a" y1="4.077" y2="4.077"/><linearGradient id="d" gradientUnits="userSpaceOnUse" x1="10.077" x2="32.077" xlink:href="#a" y1="6.077" y2="6.077"/><linearGradient id="e" gradientUnits="userSpaceOnUse" x1="9.17" x2="17.827" xlink:href="#a" y1="8.078" y2="8.078"/><linearGradient id="f" gradientUnits="userSpaceOnUse" x1="8.702" x2="16.248" xlink:href="#a" y1="10.078" y2="10.078"/><linearGradient id="g" gradientUnits="userSpaceOnUse" x1="8.545" x2="17.17" xlink:href="#a" y1="12.078" y2="12.078"/><linearGradient id="h" gradientUnits="userSpaceOnUse" x1="8.92" x2="21.264" xlink:href="#a" y1="14.078" y2="14.078"/><linearGradient id="i" gradientUnits="userSpaceOnUse" x1="10.077" x2="26.264" xlink:href="#a" y1="16.078" y2="16.078"/><linearGradient id="j" gradientUnits="userSpaceOnUse" x1="12.17" x2="28.264" xlink:href="#a" y1="18.078" y2="18.078"/><linearGradient id="k" gradientUnits="userSpaceOnUse" x1="17.17" x2="29.045" xlink:href="#a" y1="20.078" y2="20.078"/><linearGradient id="l" gradientUnits="userSpaceOnUse" x1="20.483" x2="29.764" xlink:href="#a" y1="22.078" y2="22.078"/><linearGradient id="m" gradientUnits="userSpaceOnUse" x1="21.174" x2="29.764" xlink:href="#a" y1="24.078" y2="24.078"/><linearGradient id="n" gradientUnits="userSpaceOnUse" x1="20.077" x2="28.764" xlink:href="#a" y1="26.078" y2="26.078"/><linearGradient id="o" gradientUnits="userSpaceOnUse" x1="5.412" x2="12.624" xlink:href="#a" y1="26.078" y2="26.078"/><linearGradient id="p" gradientUnits="userSpaceOnUse" x1="3.827" x2="27.858" xlink:href="#a" y1="28.078" y2="28.078"/><linearGradient id="q" gradientUnits="userSpaceOnUse" x1="6.317" x2="25.465" xlink:href="#a" y1="30.078" y2="30.078"/><linearGradient id="r" gradientUnits="userSpaceOnUse" x1="9.552" x2="20.764" xlink:href="#a" y1="32.078" y2="32.078"/><linearGradient id="s" gradientUnits="userSpaceOnUse" x1="24.421" x2="31.045" xlink:href="#a" y1="8.078" y2="8.078"/><path d="m27.7 2.6h-11.8c-.3 0-.5-.2-.5-.5s.2-.5.5-.5h11.8c.3 0 .5.2.5.5.1.3-.2.5-.5.5z" fill="url(#b)"/><path d="m30.5 4.6h-18c-.3 0-.5-.2-.5-.5s.2-.5.5-.5h18c.3 0 .5.2.5.5s-.2.5-.5.5z" fill="url(#c)"/><path d="m31.5 6.6h-20.9c-.3 0-.5-.2-.5-.5s.2-.5.5-.5h20.9c.3 0 .5.2.5.5.1.3-.2.5-.5.5z" fill="url(#d)"/><path d="m17.3 8.6h-7.6c-.3 0-.5-.2-.5-.5s.2-.5.5-.5h7.6c.3 0 .5.2.5.5s-.2.5-.5.5z" fill="url(#e)"/><path d="m15.7 10.6h-6.4c-.3 0-.5-.2-.5-.5s.2-.5.5-.5h6.4c.3 0 .6.2.6.5-.1.3-.3.5-.6.5z" fill="url(#f)"/><path d="m16.6 12.6h-7.5c-.3 0-.5-.2-.5-.5s.2-.5.5-.5h7.5c.3 0 .5.2.5.5.1.3-.2.5-.5.5z" fill="url(#g)"/><path d="m20.7 14.6h-11.2c-.3 0-.5-.2-.5-.5s.2-.5.5-.5h11.2c.3 0 .5.2.5.5.1.3-.2.5-.5.5z" fill="url(#h)"/><path d="m25.7 16.6h-15.1c-.3 0-.5-.2-.5-.5s.2-.5.5-.5h15.1c.3 0 .5.2.5.5.1.3-.2.5-.5.5z" fill="url(#i)"/><path d="m27.7 18.6h-15c-.3 0-.5-.2-.5-.5s.2-.5.5-.5h15c.3 0 .5.2.5.5.1.3-.2.5-.5.5z" fill="url(#j)"/><path d="m28.5 20.6h-10.8c-.3 0-.5-.2-.5-.5s.2-.5.5-.5h10.8c.3 0 .5.2.5.5s-.2.5-.5.5z" fill="url(#k)"/><path d="m29.2 22.6h-8.2c-.3 0-.5-.2-.5-.5s.2-.5.5-.5h8.2c.3 0 .5.2.5.5.1.3-.2.5-.5.5z" fill="url(#l)"/><path d="m29.2 24.6h-7.5c-.3 0-.5-.2-.5-.5s.2-.5.5-.5h7.5c.3 0 .5.2.5.5.1.3-.2.5-.5.5z" fill="url(#m)"/><path d="m28.2 26.6h-7.6c-.3 0-.5-.2-.5-.5s.2-.5.5-.5h7.6c.3 0 .5.2.5.5.1.3-.2.5-.5.5z" fill="url(#n)"/><path d="m12.1 26.6h-6.1c-.3 0-.5-.2-.5-.5s.2-.5.5-.5h6.1c.3 0 .5.2.5.5s-.2.5-.5.5z" fill="url(#o)"/><path d="m27.3 28.6h-22.9c-.3 0-.5-.2-.5-.5s.2-.5.5-.5h22.9c.3 0 .5.2.5.5.1.3-.2.5-.5.5z" fill="url(#p)"/><path d="m24.9 30.6h-18c-.3 0-.5-.2-.5-.5s.2-.5.5-.5h18c.3 0 .5.2.5.5.1.3-.2.5-.5.5z" fill="url(#q)"/><path d="m20.2 32.6h-10.1c-.3 0-.5-.2-.5-.5s.2-.6.5-.6h10.1c.3 0 .5.2.5.6.1.3-.2.5-.5.5z" fill="url(#r)"/><path d="m30.5 8.6h-5.5c-.3 0-.5-.2-.5-.5s.2-.5.5-.5h5.5c.3 0 .5.2.5.5s-.2.5-.5.5z" fill="url(#s)"/></svg>

================
File: background/api/parts.ts
================
import { BrowserWindow, ipcMain } from 'electron'
import {
	DBPart,
	IpcOperation,
	IpcOperationType,
	MutationPartCreate,
	MutationPartDelete,
	MutationPartRead,
	MutationPartUpdate,
	MutatedPart,
	Part
} from '../interfaces'
import { db, InsertResolution, UpdateResolution } from '../db'
import { v4 as uuid } from 'uuid'
import { coreHandler } from '../coreHandler'
import { getMutatedPiecesFromPart } from './pieces'
import { mutations as rundownMutations } from './rundowns'
import { mutations as segmentsMutations } from './segments'
import { stringifyError } from '../util'
⋮----
async function mutatePart(part: Part): Promise<MutatedPart>
⋮----
async function sendPartDiffToCore(oldPart: Part, newPart: Part)
⋮----
async create(payload: MutationPartCreate): Promise<
async read(
		payload: Partial<MutationPartRead>
): Promise<
async update(payload: MutationPartUpdate): Promise<
async delete(payload: MutationPartDelete): Promise<
⋮----
export async function init(window: BrowserWindow): Promise<void>
⋮----
export async function sendPartUpdateToCore(partId: string)
⋮----
export async function getMutatedPartsFromSegment(segmentId: string): Promise<MutatedPart[]>

================
File: background/api/pieceManifests.ts
================
import { ipcMain } from 'electron'
import {
	DBPieceTypeManifest,
	IpcOperation,
	IpcOperationType,
	MutationPieceTypeManifestCreate,
	MutationPieceTypeManifestDelete,
	MutationPieceTypeManifestRead,
	MutationPieceTypeManifestUpdate,
	PieceTypeManifest
} from '../interfaces'
import { db, InsertResolution, UpdateResolution } from '../db'
import { v4 as uuid } from 'uuid'
import { RunResult } from 'sqlite3'
⋮----
async create(
		payload: MutationPieceTypeManifestCreate
): Promise<
async read(
		payload: Partial<MutationPieceTypeManifestRead>
): Promise<
async update(
		payload: MutationPieceTypeManifestUpdate
): Promise<
async delete(payload: MutationPieceTypeManifestDelete): Promise<

================
File: background/api/pieces.ts
================
import { BrowserWindow, ipcMain } from 'electron'
import {
	DBPiece,
	IpcOperation,
	IpcOperationType,
	MutatedPiece,
	MutationPieceCreate,
	MutationPieceDelete,
	MutationPieceRead,
	MutationPieceUpdate,
	Piece
} from '../interfaces'
import { db, InsertResolution, UpdateResolution } from '../db'
import { v4 as uuid } from 'uuid'
import { sendPartUpdateToCore } from './parts'
import { stringifyError } from '../util'
⋮----
async create(payload: MutationPieceCreate): Promise<
⋮----
// const document = await new Promise<DBPiece>((resolve, reject) => db.get(`
// 	SELECT *
// 	FROM pieces
// 	WHERE id = ?
// 	LIMIT 1;
// `, [ id ], (e, r) => {
// 	console.log(e, r)
// 	resolve(r)
// }))
⋮----
// return {
// 	...JSON.parse(document.document),
// 	id: document.id,
// 	playlistId: document.playlistId,
// 	rundownId: document.rundownId,
// 	segmentId: document.segmentId,
// 	partId: document.partId
// }
⋮----
async read(
		payload: Partial<MutationPieceRead>
): Promise<
async update(payload: MutationPieceUpdate): Promise<
async delete(payload: MutationPieceDelete): Promise<
⋮----
export async function init(window: BrowserWindow): Promise<void>
⋮----
export async function getMutatedPiecesFromPart(partId: string): Promise<MutatedPiece[]>

================
File: background/api/playlists.ts
================
import { ipcMain } from 'electron'
import { DBPlaylist, IpcOperation, IpcOperationType } from '../interfaces'
import { db, InsertResolution } from '../db'
import { v4 as uuid } from 'uuid'
import { RunResult } from 'sqlite3'

================
File: background/api/rundowns.ts
================
import { BrowserWindow, ipcMain } from 'electron'
import {
	DBRundown,
	IpcOperation,
	IpcOperationType,
	MutationRundownCreate,
	MutationRundownDelete,
	MutationRundownRead,
	MutationRundownUpdate,
	MutatedRundown,
	Rundown
} from '../interfaces'
import { db, InsertResolution, UpdateResolution } from '../db'
import { v4 as uuid } from 'uuid'
import { coreHandler } from '../coreHandler'
import { getMutatedSegmentsFromRundown } from './segments'
import { stringifyError } from '../util'
⋮----
export async function mutateRundown(rundown: Rundown): Promise<MutatedRundown>
⋮----
type: 'sofie-rundown-editor', // ?
⋮----
async function sendRundownDiffToCore(oldDocument: Rundown, newDocument: Rundown)
⋮----
async create(payload: MutationRundownCreate): Promise<
async read(
		payload: Partial<MutationRundownRead>
): Promise<
async update(payload: MutationRundownUpdate): Promise<
async delete(payload: MutationRundownDelete): Promise<
⋮----
export async function init(window: BrowserWindow): Promise<void>

================
File: background/api/segments.ts
================
import { BrowserWindow, ipcMain } from 'electron'
import {
	DBSegment,
	IpcOperation,
	IpcOperationType,
	MutationSegmentCreate,
	MutationSegmentDelete,
	MutationSegmentRead,
	MutationSegmentUpdate,
	MutatedSegment,
	Segment
} from '../interfaces'
import { db, InsertResolution, UpdateResolution } from '../db'
import { v4 as uuid } from 'uuid'
import { coreHandler } from '../coreHandler'
import { getMutatedPartsFromSegment } from './parts'
import { mutations as rundownMutations } from './rundowns'
import { stringifyError } from '../util'
⋮----
async function mutateSegment(segment: Segment): Promise<MutatedSegment>
⋮----
async function sendSegmentDiffToCore(oldSegment: Segment, newSegment: Segment)
⋮----
async create(payload: MutationSegmentCreate): Promise<
async read(
		payload: Partial<MutationSegmentRead>
): Promise<
async update(payload: MutationSegmentUpdate): Promise<
async delete(payload: MutationSegmentDelete): Promise<
⋮----
export async function init(window: BrowserWindow): Promise<void>
⋮----
export async function getMutatedSegmentsFromRundown(rundownId: string): Promise<MutatedSegment[]>

================
File: background/api/settings.ts
================
import { ipcMain } from 'electron'
import {
	DBSettings,
	IpcOperation,
	IpcOperationType,
	ApplicationSettings,
	MutationApplicationSettingsCreate,
	MutationApplicationSettingsUpdate
} from '../interfaces'
import { db, InsertResolution, UpdateResolution } from '../db'
import { PARTS_MANIFEST, PIECES_MANIFEST } from '../manifest'
⋮----
async create(
		payload: MutationApplicationSettingsCreate
): Promise<
async read(): Promise<
async update(
		payload: MutationApplicationSettingsUpdate
): Promise<
async reset(): Promise<
⋮----
// Reset to defaults from manifest
⋮----
// Return the current settings
⋮----
// export async function initializeDefaults() {
// 	mutations.read().then(({ result }) => {
// 		if (!result) {
// 			mutations.create(DEFAULT_SETTINGS)
// 		}
// 	})
// }
export async function initializeDefaults()
⋮----
// Check if settings exist
⋮----
// If no settings exist, create them
⋮----
// If settings already exist, update them to defaults
⋮----
// Reset piece type manifests
// First, get all existing manifests
⋮----
// Delete them all
⋮----
// Insert the defaults

================
File: background/configManifest.ts
================
import {
	DeviceConfigManifest,
	JSONBlobStringify,
	JSONSchema
} from '@sofie-automation/server-core-integration'

================
File: background/coreHandler.ts
================
import {
	CoreConnection,
	CoreCredentials,
	CoreOptions,
	DDPConnectorOptions,
	Observer,
	PeripheralDevicePubSub,
	PeripheralDeviceCommand,
	PeripheralDevicePubSubCollectionsNames,
	stringifyError
} from '@sofie-automation/server-core-integration'
⋮----
import { StatusCode } from '@sofie-automation/shared-lib/dist/lib/status'
import { protectString } from '@sofie-automation/shared-lib/dist/lib/protectedString'
import { DEVICE_CONFIG_MANIFEST } from './configManifest'
import { mutations as settingsMutations } from './api/settings'
import { BrowserWindow } from 'electron'
import { CoreConnectionInfo, CoreConnectionStatus } from './interfaces'
import { mutateRundown, mutations as rundownMutations } from './api/rundowns'
import { PeripheralDeviceCommandId } from '@sofie-automation/shared-lib/dist/core/model/Ids'
⋮----
// eslint-disable-next-line @typescript-eslint/no-var-requires
⋮----
export interface DeviceConfig {
	deviceId: string
	deviceToken: string
}
⋮----
export class CoreHandler
⋮----
public get connectionInfo(): Readonly<CoreConnectionInfo>
⋮----
constructor()
⋮----
// todo - have settings for this
⋮----
async init(window: BrowserWindow)
⋮----
// if (this._isInitialized) this.onConnectionRestored()
⋮----
// if (this._process && this._process.certificates.length) {
// 	ddpConfig.tlsOpts = {
// 		ca: this._process.certificates
// 	}
// }
⋮----
this.core.destroy() // Cleanup to prevent EventEmitter leaks.
this.init(window) // Keep retrying until successful.
⋮----
/**
	 * Subscribes to events in the core.
	 */
async setupSubscriptionsAndObservers(): Promise<void>
⋮----
// console.log('setupObservers', this.core.deviceId)
⋮----
getCoreConnectionOptions(deviceOptions: DeviceConfig, name: string): CoreOptions
⋮----
versions: {}, // todo - unhardcode
⋮----
watchDog: false, // todo - unhardcode
⋮----
setStatus(statusCode: StatusCode, messages: string[])
⋮----
/**
	 * Listen for commands and execute.
	 */
setupObserverForPeripheralDeviceCommands()
⋮----
this.killProcess(0) // just make sure it exists
⋮----
/**
		 * Called when a command is added/changed. Executes that command.
		 * @param {string} id Command id to execute.
		 */
const addedChangedCommand = (id: PeripheralDeviceCommandId) =>
⋮----
// any should be PeripheralDeviceCommand
⋮----
killProcess(actually: number)
⋮----
async triggerReloadRundown(rundownId: string)
⋮----
executeFunction(cmd: PeripheralDeviceCommand, fcnObject: CoreHandler)
⋮----
if (this._executedFunctions.has(cmd._id)) return // prevent it from running multiple times
⋮----
// eslint-disable-next-line @typescript-eslint/no-explicit-any
const cb = (err: unknown, res?: any) =>
⋮----
//@ts-expect-error - functionName is a string
⋮----
retireExecuteFunction(cmdId: PeripheralDeviceCommandId): void
⋮----
private _getVersions()

================
File: background/db.ts
================
import sqlite3 from 'sqlite3'
import path from 'path'
⋮----
export interface InsertResolution {
	result: number | undefined
	error: Error | undefined
}
⋮----
export interface UpdateResolution {
	result: boolean | undefined
	error: Error | undefined
}

================
File: background/index.ts
================
import { BrowserWindow, ipcMain } from 'electron'
import { IpcOperation, IpcOperationType } from './interfaces'
⋮----
import { init as initRundowns } from './api/rundowns'
import { init as initSegments } from './api/segments'
import { init as initParts } from './api/parts'
import { init as initPieces } from './api/pieces'
⋮----
import { coreHandler } from './coreHandler'
⋮----
export interface BasicPayload extends Record<string, unknown> {
	playerId: number
}
⋮----
export class ControlAPI
⋮----
constructor(window: BrowserWindow)
⋮----
async init(): Promise<void>

================
File: background/interfaces.ts
================
export interface Playlist {
	/** Id of the playlist. */
	id: string
	/** Name of the playlist */
	name: string
}
⋮----
/** Id of the playlist. */
⋮----
/** Name of the playlist */
⋮----
export interface Rundown {
	/** Id of the rundown as reported by the ingest gateway. Must be unique for each rundown owned by the gateway */
	id: string
	/** id of the playlist this rundown is in */
	playlistId: string | null
	/** Name of the rundown */
	name: string
	/** Whether to sync the rundown to Sofie */
	sync: boolean

	/** Date of when the rundown is supposed to start */
	expectedStartTime?: number
	/** Date of when the rundown is supposed to end */
	expectedEndTime?: number
	/** User configurable fields */
	metaData?: Record<string, string | number | boolean>
}
⋮----
/** Id of the rundown as reported by the ingest gateway. Must be unique for each rundown owned by the gateway */
⋮----
/** id of the playlist this rundown is in */
⋮----
/** Name of the rundown */
⋮----
/** Whether to sync the rundown to Sofie */
⋮----
/** Date of when the rundown is supposed to start */
⋮----
/** Date of when the rundown is supposed to end */
⋮----
/** User configurable fields */
⋮----
export interface Segment {
	/** Id of the segment as reported by the ingest gateway. Must be unique for each segment in the rundown */
	id: string
	/** Id of the playlist this segment belongs to */
	playlistId: string | null
	/** Id of the rundown this segment belongs to */
	rundownId: string
	/** Name of the segment */
	name: string
	/** Rank of the segment within the rundown */
	rank: number
	/** Whether this segment is floated */
	float: boolean
}
⋮----
/** Id of the segment as reported by the ingest gateway. Must be unique for each segment in the rundown */
⋮----
/** Id of the playlist this segment belongs to */
⋮----
/** Id of the rundown this segment belongs to */
⋮----
/** Name of the segment */
⋮----
/** Rank of the segment within the rundown */
⋮----
/** Whether this segment is floated */
⋮----
export interface Part {
	/** Id of the part as reported by the ingest gateway. Must be unique for each part in the rundown */
	id: string
	/** Id of the playlist this part belongs to */
	playlistId: string | null
	/** Id of the rundown this part belongs to */
	rundownId: string
	/** Id of the segment this part belongs to */
	segmentId: string
	/** Name of the part */
	name: string
	/** Rank of the part within the segmetn */
	rank: number
	/** Whether this part is floated */
	float: boolean

	/** Raw payload of the part. Only used by the blueprints */
	payload: {
		script?: string
		type?: string
		duration?: number
	}
}
⋮----
/** Id of the part as reported by the ingest gateway. Must be unique for each part in the rundown */
⋮----
/** Id of the playlist this part belongs to */
⋮----
/** Id of the rundown this part belongs to */
⋮----
/** Id of the segment this part belongs to */
⋮----
/** Name of the part */
⋮----
/** Rank of the part within the segmetn */
⋮----
/** Whether this part is floated */
⋮----
/** Raw payload of the part. Only used by the blueprints */
⋮----
export interface Piece {
	/** Id of the adlib as reported by the ingest source. Must be unique for each adlib */
	id: string
	/** Id of the playlist this piece belongs to */
	playlistId: string | null
	/** Id of the rundown this piece belongs to */
	rundownId: string
	/** Id of the segment this piece belongs to */
	segmentId: string
	/** Id of the part this piece belongs to */
	partId: string
	/** Name of the piece */
	name: string

	start?: number
	duration?: number // todo - timing type for infintes

	pieceType: string
	payload: Record<string, string | number | boolean>
}
⋮----
/** Id of the adlib as reported by the ingest source. Must be unique for each adlib */
⋮----
/** Id of the playlist this piece belongs to */
⋮----
/** Id of the rundown this piece belongs to */
⋮----
/** Id of the segment this piece belongs to */
⋮----
/** Id of the part this piece belongs to */
⋮----
/** Name of the piece */
⋮----
duration?: number // todo - timing type for infintes
⋮----
export interface DBPlaylist {
	document: string // Omit<Playlist, 'id'>
	id: string
}
⋮----
document: string // Omit<Playlist, 'id'>
⋮----
export interface DBRundown {
	document: string // Omit<Rundown, 'id'>
	id: string
	playlistId?: string
}
⋮----
document: string // Omit<Rundown, 'id'>
⋮----
export interface DBSegment {
	document: string // Omit<Segment, 'id'>
	id: string
	playlistId?: string
	rundownId: string
}
⋮----
document: string // Omit<Segment, 'id'>
⋮----
export interface DBPart {
	document: string // Omit<Part, 'id'>
	id: string
	playlistId?: string
	rundownId: string
	segmentId: string
}
⋮----
document: string // Omit<Part, 'id'>
⋮----
export interface DBPiece {
	document: string // Omit<Piece, 'id'>
	id: string
	playlistId?: string
	rundownId: string
	segmentId: string
	partId: string
}
⋮----
document: string // Omit<Piece, 'id'>
⋮----
export enum ManifestFieldType {
	String = 'string',
	Number = 'number',
	Boolean = 'boolean'
}
⋮----
export type RundownMetadataManifest = RundownMetadataEntryManifest[]
export interface RundownMetadataEntryManifest {
	id: string
	label: string
	type: ManifestFieldType
}
⋮----
export type PiecesManifest = PieceTypeManifest[]
⋮----
export interface PieceTypeManifest {
	id: string
	name: string
	shortName: string
	colour: string
	includeTypeInName?: boolean

	payload: PiecePayloadManifest[]
}
export interface DBPieceTypeManifest {
	id: string
	document: string
}
⋮----
export interface PiecePayloadManifest {
	id: string
	label: string
	type: ManifestFieldType
	includeInName?: boolean
}
⋮----
export interface ApplicationSettings {
	coreUrl?: string
	corePort?: number

	partTypes: string[]
	rundownMetadata: RundownMetadataManifest
}
export interface DBSettings {
	id: string
	document: string
}
⋮----
export enum IpcOperationType {
	Create = 'create',
	Read = 'read',
	Update = 'update',
	Delete = 'delete',
	Reset = 'reset'
}
⋮----
export interface IpcOperation {
	type: IpcOperationType
	// eslint-disable-next-line @typescript-eslint/no-explicit-any
	payload: any
}
⋮----
// eslint-disable-next-line @typescript-eslint/no-explicit-any
⋮----
export type MutationPieceCreate = Piece
⋮----
export type MutationPieceRead = Pick<Piece, 'id' | 'rundownId' | 'segmentId' | 'partId'>
⋮----
export type MutationPieceUpdate = Piece
⋮----
export type MutationPieceDelete = Pick<Piece, 'id'>
⋮----
export interface MutatedRundown {
	externalId: string
	name: string
	type: 'sofie-rundown-editor'
	segments: MutatedSegment[]
	payload: {
		// eslint-disable-next-line @typescript-eslint/no-explicit-any
		[key: string]: any
		name: string
		expectedStart: number | undefined
		expectedEnd: number | undefined
	}
}
⋮----
// eslint-disable-next-line @typescript-eslint/no-explicit-any
⋮----
export interface MutatedSegment {
	externalId: string
	name: string
	rank: number
	payload: { name: string; rank: number }
	parts: MutatedPart[]
}
⋮----
export interface MutatedPart {
	externalId: string
	name: string
	rank: number
	payload: {
		segmentId: string
		externalId: string
		rank: number
		name: string
		type: string | undefined
		float: boolean
		script: string | undefined
		duration: number | undefined
		pieces: MutatedPiece[]
	}
}
⋮----
export interface MutatedPiece {
	id: string
	objectType: string
	objectTime: number | undefined
	duration: number | undefined
	clipName: string | undefined
	attributes: {
		// eslint-disable-next-line @typescript-eslint/no-explicit-any
		[key: string]: any
		adlib: boolean
	}
	position: number | undefined
}
⋮----
// eslint-disable-next-line @typescript-eslint/no-explicit-any
⋮----
export type MutationPartCreate = Part
⋮----
export type MutationPartRead = Pick<Part, 'id' | 'rundownId' | 'segmentId'>
⋮----
export type MutationPartUpdate = Part
⋮----
export type MutationPartDelete = Pick<Part, 'id'>
⋮----
export type MutationPieceTypeManifestCreate = Pick<PieceTypeManifest, 'id' | 'name'>
⋮----
export type MutationPieceTypeManifestRead = Pick<PieceTypeManifest, 'id'>
⋮----
export type MutationPieceTypeManifestUpdate = Pick<PieceTypeManifest, 'id'> & {
	update: Pick<PieceTypeManifest, 'name' | 'shortName' | 'colour' | 'includeTypeInName' | 'id'>
}
⋮----
export type MutationPieceTypeManifestDelete = Pick<PieceTypeManifest, 'id'>
⋮----
export type MutationRundownCreate = Rundown
⋮----
export type MutationRundownRead = Pick<Rundown, 'id'>
⋮----
export type MutationRundownUpdate = Rundown
⋮----
export type MutationRundownDelete = Pick<Rundown, 'id'>
⋮----
export type MutationSegmentCreate = Segment
⋮----
export type MutationSegmentRead = Pick<Segment, 'id' | 'rundownId'>
⋮----
export type MutationSegmentUpdate = Segment
⋮----
export type MutationSegmentDelete = Pick<Segment, 'id'>
⋮----
export type MutationApplicationSettingsCreate = ApplicationSettings
⋮----
export type MutationApplicationSettingsUpdate = ApplicationSettings
⋮----
export enum CoreConnectionStatus {
	CONNECTED = 'Connected',
	DISCONNECTED = 'Disconnected'
}
⋮----
export interface CoreConnectionInfo {
	status: CoreConnectionStatus
	url?: string
	port?: number
}
⋮----
export interface SerializedRundown {
	rundown: Rundown
	segments: Segment[]
	parts: Part[]
	pieces: Piece[]
}

================
File: background/manifest.ts
================
import { RundownMetadataManifest, PiecesManifest, ManifestFieldType } from './interfaces'
⋮----
// TODO - make this some JSON file for better flexibility
⋮----
// Define part types that can be used in rundowns
// ToDo - make these in better structure (id: type, name: type, etc)
⋮----
// Define pieces manifest with all piece types and their properties

================
File: background/util.ts
================
/** Make a string out of an error (or other equivalents), including any additional data such as stack trace if available */
export function stringifyError(error: unknown, noStack = false): string
export function stringifyErrorInner(error: unknown):
⋮----
// Is a Meteor.Error
⋮----
// Is an Error
⋮----
// Try to stringify the object:

================
File: components/rundown/PartEditor.vue
================
<template>
	<div class="part-editor d-flex flex-column">
		<h2>Part</h2>
		<b-form @submit.prevent="update">
			<b-form-group label="Name:">
				<b-form-input v-model="name"></b-form-input>
			</b-form-group>

			<b-form-group label="Float:">
				<b-form-checkbox v-model="float"></b-form-checkbox>
			</b-form-group>

			<b-form-group label="Type:">
				<!-- <b-form-input v-model="type"></b-form-input> -->
			</b-form-group>
			<b-form-select v-model="type" :options="types"></b-form-select>

			<b-form-group label="Duration:">
				<b-form-input number v-model="duration"></b-form-input>
			</b-form-group>

			<b-form-group label="Script:">
				<b-form-textarea v-model="script"></b-form-textarea>
			</b-form-group>

			<div class="buttons d-flex flex-row justify-content-between">
				<b-button variant="danger" v-b-modal.delete-rd>Delete</b-button>
				<b-button-group>
					<b-button @click="reset">Cancel</b-button>
					<b-button type="submit" @click="update" variant="primary">{{ labelOnUpdateButton }}</b-button>
				</b-button-group>
			</div>
		</b-form>

		<b-modal id="delete-rd" title="Delete segment" @ok="deleteRundown" ok-variant="danger" ok-title="Delete">
			<p class="my-4">Are you sure you want to delete "{{ part.name }}?"</p>
		</b-modal>
	</div>
</template>
⋮----
<!-- <b-form-input v-model="type"></b-form-input> -->
⋮----
<b-button type="submit" @click="update" variant="primary">{{ labelOnUpdateButton }}</b-button>
⋮----
<p class="my-4">Are you sure you want to delete "{{ part.name }}?"</p>
⋮----
<script lang="ts">
import { Part, Rundown } from '@/background/interfaces'
import store from '@/store'
import Vue from 'vue'

function editField<T>(field: string, index?: string) {
	return {
		[field]: {
			get(): T | undefined {
				// eslint-disable-next-line @typescript-eslint/no-explicit-any
				const self = this as any
				if (index) {
					return self.editObject ? self.editObject[index]?.[field] : self.part?.[index]?.[field]
				} else {
					return self.editObject ? self.editObject[field] : self.part?.[field]
				}
			},
			set(value: T) {
				// eslint-disable-next-line @typescript-eslint/no-explicit-any
				const self = this as any
				if (!self.editObject) {
					self.editObject = {
						...self.part
					}
				}
				if (index) {
					if (!self.editObject[index]) self.editObject[index] = {}

					self.editObject[index][field] = value
				} else {
					self.editObject[field] = value
				}
			}
		}
	}
}

export default Vue.extend({
	computed: {
		id(): string {
			return this.$route.params.part
		},
		rundown: {
			get(): Partial<Rundown> {
				return { ...(store.state.rundowns.find((r) => r.id === this.$route.params.id) || {}) }
			}
		},
		part() {
			return store.state.parts.find((s) => s.id === this.$route.params.part)
		},

		...editField<string>('name'),
		...editField<boolean>('float'),
		...editField<string>('type', 'payload'),
		...editField<number>('duration', 'payload'),
		...editField<number>('script', 'payload'),

		types() {
			return store.state.settings.partTypes
		},
		labelOnUpdateButton(): string {
			return this.rundown.sync ? 'Update' : 'Save'
		}
	},
	data() {
		return {
			editObject: undefined as Partial<Part> | undefined
		}
	},
	methods: {
		reset() {
			this.editObject = undefined
		},
		deleteRundown() {
			store.dispatch('removePart', this.id)
			this.$router.push('/rundown/' + this.rundown.id)
		},
		update() {
			if (this.editObject) {
				store.dispatch('updatePart', {
					...this.editObject,
					payload: {
						...(this.editObject.payload || {})
					}
				})
			}
		}
	},
	watch: {
		$route: function () {
			this.editObject = undefined
		}
	}
})
</script>
⋮----
<style scoped>
.part-editor {
	background-color: rgb(30, 30, 30);
	padding: 2em;
}

.form-group {
	margin: 0.5em 0;
}

.buttons {
	margin: 1em 0;
}
</style>

================
File: components/rundown/PieceEditor.vue
================
<template>
	<div class="segment-editor d-flex flex-column">
		<h2>Piece</h2>

		<b-form @submit.prevent="update">

			<!-- <b-form-group label="Float:">
			<b-form-checkbox v-model="float"></b-form-checkbox>
		</b-form-group> -->

			<p>Piece type: {{ pieceManifest.name }}</p>

			<b-form-group label="Duration:">
				<b-form-input number v-model="duration"></b-form-input>
			</b-form-group>

			<b-form-group label="Start:">
				<b-form-input number v-model="start"></b-form-input>
			</b-form-group>

			<b-form-group v-for="m in pieceManifest.payload" :key="m.id" :label="m.label + ':'">
				<b-form-input v-if="m.type === 'number'" number :value="payload[m.id]"
					@update="(v) => updatePayload(m.id, v)"></b-form-input>
				<b-form-input v-if="m.type === 'string'" :value="payload[m.id]"
					@update="(v) => updatePayload(m.id, v)"></b-form-input>
				<b-form-checkbox v-if="m.type === 'boolean'" :checked="payload[m.id]"
					@input="(v) => updatePayload(m.id, v)"></b-form-checkbox>
			</b-form-group>

			<div class="buttons d-flex flex-row justify-content-between">
				<b-button variant="danger" v-b-modal.delete-rd>Delete</b-button>
				<b-button-group>
					<b-button @click="reset">Cancel</b-button>
					<b-button type="submit" @click="update" variant="primary">{{ labelOnUpdateButton }}</b-button>
				</b-button-group>
			</div>
		</b-form>

		<b-modal id="delete-rd" title="Delete segment" @ok="deletePiece" ok-variant="danger" ok-title="Delete">
			<p class="my-4">Are you sure you want to delete "{{ piece.name }}?"</p>
		</b-modal>
	</div>
</template>
⋮----
<!-- <b-form-group label="Float:">
			<b-form-checkbox v-model="float"></b-form-checkbox>
		</b-form-group> -->
⋮----
<p>Piece type: {{ pieceManifest.name }}</p>
⋮----
<b-button type="submit" @click="update" variant="primary">{{ labelOnUpdateButton }}</b-button>
⋮----
<p class="my-4">Are you sure you want to delete "{{ piece.name }}?"</p>
⋮----
<script lang="ts">
import { Piece, PieceTypeManifest, Rundown } from '@/background/interfaces'
import { editField, Nullable } from '@/util/lib'
import store from '@/store'
import Vue from 'vue'

export default Vue.extend({
	computed: {
		id(): string {
			return this.$route.params.piece
		},
		rundown: {
			get(): Partial<Rundown> {
				return { ...(store.state.rundowns.find((r) => r.id === this.$route.params.id) || {}) }
			}
		},
		piece(): Piece | undefined {
			return store.state.pieces.find((p) => p.id === this.$route.params.piece)
		},
		pieceManifest(): Partial<PieceTypeManifest> {
			return store.state.piecesManifest.find((m) => m.id === this.piece?.pieceType) || {}
		},

		payload: {
			get(): Piece['payload'] {
				return this.piece?.payload || {}
			}
		},
		labelOnUpdateButton(): string {
			return this.rundown.sync ? 'Update' : 'Save'
		},

		...editField('piece', 'duration'),
		...editField('piece', 'start')
	},
	data() {
		return {
			editObject: undefined as
				| (Partial<Omit<Piece, 'payload'>> & { payload?: Nullable<Piece['payload']> })
				| undefined
		}
	},
	methods: {
		reset() {
			this.editObject = undefined
		},
		deletePiece() {
			const partId = this.piece?.partId
			store.dispatch('removePiece', this.id)
			this.$router.push(`/rundown/${this.rundown.id}/part/${partId}`)
		},
		updatePayload<T extends keyof Piece['payload']>(field: T, value: Piece['payload'][T] | null) {
			if (!this.editObject) {
				this.editObject = {
					...this.piece
				}
			}
			if (!this.editObject['payload']) {
				this.editObject.payload = {}
			}
			if (value === undefined || value === '') value = null
			this.editObject.payload[field] = value
		},
		update() {
			if (!this.pieceManifest.payload) {
				// This should only happen on Pieces which no longer have a valid Piece Manifest type.
				return
			}

			let name = this.pieceManifest.includeTypeInName ? this.pieceManifest.name + ' ' : ''
			name += this.pieceManifest.payload
				.filter((m) => m.includeInName)
				.map((m) => m.id)
				.map((id) => this.editObject?.payload?.[id])
				.join(' - ')

			if (this.editObject) {
				store.dispatch('updatePiece', {
					...this.editObject,
					name,
					payload: {
						...(this.editObject.payload || {})
					}
				})
			}
		}
	},
	watch: {
		$route: function () {
			this.editObject = undefined
		}
	}
})
</script>
⋮----
<style scoped>
.segment-editor {
	padding: 2em;
}

.form-group {
	margin: 0.5em 0;
}

.buttons {
	margin: 1em 0;
}
</style>

================
File: components/rundown/PieceList.vue
================
<template>
	<div class="piece-list d-flex flex-column">
		<router-link
			class="piece d-flex"
			v-for="piece in pieces"
			:key="piece.id"
			:to="`/rundown/${rundown.id}/piece/${piece.id}`"
		>
			<div class="type" :style="{ backgroundColor: piece.manifest.colour }">
				{{ piece.manifest.shortName }}
			</div>
			<div class="name flex-grow-1">{{ piece.name }}</div>
			<div class="start">{{ piece.start }}</div>
			<div class="duration">{{ piece.duration }}</div>
		</router-link>
		<div class="piece new" v-b-modal.new-piece>New piece</div>

		<b-modal id="new-piece" title="New piece" @ok="newPiece" ok-title="Create">
			Piece type: <b-form-select v-model="newPieceType" :options="pieceTypes"></b-form-select>
		</b-modal>
	</div>
</template>
⋮----
{{ piece.manifest.shortName }}
⋮----
<div class="name flex-grow-1">{{ piece.name }}</div>
<div class="start">{{ piece.start }}</div>
<div class="duration">{{ piece.duration }}</div>
⋮----
<script lang="ts">
import { Piece, PieceTypeManifest, Rundown } from '@/background/interfaces'
import { toTime } from '@/util/lib'
import store from '@/store'
import Vue from 'vue'

export default Vue.extend({
	computed: {
		rundown(): Rundown | undefined {
			return store.state.rundowns.find((r) => r.id === this.$route.params.id) || undefined
		},
		partId(): string {
			if (this.$route.params.piece) {
				const piece = store.state.pieces.find((p) => p.id === this.$route.params.piece)
				if (piece) return piece.partId
			} else if (this.$route.params.part) {
				return this.$route.params.part
			}
			return ''
		},
		segmentId(): string {
			if (this.$route.params.piece) {
				const piece = store.state.pieces.find((p) => p.id === this.$route.params.piece)
				if (piece) return piece.segmentId
			} else if (this.$route.params.part) {
				const part = store.state.parts.find((p) => p.id === this.$route.params.part)
				if (part) return part.segmentId
			}
			return ''
		},
		pieces(): (Omit<Piece, 'start' | 'duration'> & {
			start?: string
			duration?: string
			manifest?: Partial<PieceTypeManifest>
		})[] {
			return store.state.pieces
				.filter((piece) => piece.partId === this.partId)
				.map((piece) => ({
					...piece,
					start: piece.start !== undefined ? toTime(piece.start) : undefined,
					duration: piece.duration !== undefined ? toTime(piece.duration) : undefined,
					manifest: store.state.piecesManifest.find((m) => m.id === piece.pieceType) || {}
				}))
		},
		pieceTypes() {
			return store.state.piecesManifest.map((m) => ({
				value: m.id,
				text: m.name
			}))
		}
	},
	data() {
		return {
			newPieceType: undefined
		}
	},
	methods: {
		async newPiece() {
			if (!this.newPieceType) {
				return
			}

			const piece = await store.dispatch('newPiece', {
				playlistId: this.rundown?.playlistId,
				rundownId: this.rundown?.id,
				segmentId: this.segmentId,
				partId: this.partId,
				pieceType: this.newPieceType
			})
			this.$router.push(`/rundown/${this.rundown?.id}/piece/${piece.id}`)
		}
	}
})
</script>
⋮----
<style scoped>
.piece-list {
	background-color: #000;
	padding: 2em;
}

a {
	color: white;
	text-decoration: none;
}

.piece {
	min-height: 2em;
	line-height: 2em;
}
.piece:hover {
	background: #777;
}
.piece div {
	border: solid 1px #000;
}
.piece .name {
	padding: 0 0.2em;
}
.piece .start,
.piece .duration {
	min-width: 60px;
}
.piece .type {
	min-width: 80px;
}
.piece .start,
.piece .duration,
.piece .type {
	text-align: center;
}

.new {
	color: #777;
}
.new:hover {
	color: white;
	cursor: pointer;
}

.active,
.router-link-active {
	border: 1px solid #009dff;
}
</style>

================
File: components/rundown/RundownEditor.vue
================
<template>
	<div class="rundown-editor d-flex flex-column">
		<h2>Rundown</h2>

		<b-form @submit.prevent="update">
			<b-form-group label="Name:">
				<b-form-input v-model="name"></b-form-input>
			</b-form-group>

			<b-form-group label="Sync to Sofie:">
				<b-form-checkbox switch v-model="sync"></b-form-checkbox>
			</b-form-group>

			<b-form-group label="Start date:">
				<b-form-datepicker reset-button v-model="startDate"></b-form-datepicker>
			</b-form-group>

			<b-form-group label="Start time:">
				<b-form-timepicker :disabled="!startDate" reset-button v-model="startTime"></b-form-timepicker>
			</b-form-group>

			<b-form-group label="End date:">
				<b-form-datepicker reset-button v-model="endDate"></b-form-datepicker>
			</b-form-group>

			<b-form-group label="End time:">
				<b-form-timepicker :disabled="!endDate" reset-button v-model="endTime"></b-form-timepicker>
			</b-form-group>

			<b-form-group v-for="m in metaDataManifest" :key="m.id" :label="m.label + ':'">
				<b-form-input v-if="m.type === 'number'" number :value="metaData[m.id]"
					@update="(v) => updateMetaData(m.id, v)"></b-form-input>
				<b-form-input v-if="m.type === 'string'" :value="metaData[m.id]"
					@update="(v) => updateMetaData(m.id, v)"></b-form-input>
				<b-form-checkbox v-if="m.type === 'boolean'" :value="metaData[m.id]"
					@update="(v) => updateMetaData(m.id, v)"></b-form-checkbox>
			</b-form-group>
		</b-form>

		<div class="buttons d-flex flex-row justify-content-between">
			<b-button variant="danger" v-b-modal.delete-rd>Delete</b-button>
			<div class="d-flex">
				<b-button-group>
					<b-button class="export-button" @click="exportRundown">Export</b-button>
				</b-button-group>
				<b-button-group>
					<b-button @click="reset">Cancel</b-button>
					<b-button type="submit" @click="update" variant="primary">{{ labelOnUpdateButton }}</b-button>
				</b-button-group>
			</div>
		</div>

		<b-modal id="delete-rd" title="Delete rundown" @ok="deleteRundown" ok-variant="danger" ok-title="Delete">
			<p class="my-4">Are you sure you want to delete "{{ rundown.name }}?"</p>
		</b-modal>
	</div>
</template>
⋮----
<b-button type="submit" @click="update" variant="primary">{{ labelOnUpdateButton }}</b-button>
⋮----
<p class="my-4">Are you sure you want to delete "{{ rundown.name }}?"</p>
⋮----
<script lang="ts">
import { IpcOperation, IpcOperationType, Rundown, SerializedRundown } from '@/background/interfaces'
import { editField, literal, Nullable } from '@/util/lib'
import store from '@/store'
import Vue from 'vue'
import { saveToFile } from '../../util/fs'

const { ipcRenderer } = window

export default Vue.extend({
	computed: {
		id(): string {
			return this.$route.params.id
		},
		rundown: {
			get(): Partial<Rundown> {
				return { ...(store.state.rundowns.find((r) => r.id === this.id) || {}) }
			}
		},
		...editField('rundown', 'name'),
		...editField('rundown', 'sync'),
		...editField('rundown', 'metaData', undefined, {}),
		startDate: {
			get(): string | undefined {
				const start = this.editObject
					? this.editObject.expectedStartTime
					: this.rundown?.expectedStartTime
				if (!start) return undefined

				const date = new Date(start)
				return `${date.getFullYear()}-${date.getMonth() + 1}-${date.getDate()}`
			},
			set(date: string) {
				if (!this.editObject) {
					this.editObject = {
						...this.rundown
					}
				}

				if (!date) {
					Vue.set(this.editObject, 'expectedStartTime', null)
				} else {
					Vue.set(
						this.editObject,
						'expectedStartTime',
						new Date(date + ' ' + (this.startTime || '00:00:00')).getTime()
					)
				}
			}
		},
		startTime: {
			get(): string | undefined {
				const start = this.editObject
					? this.editObject.expectedStartTime
					: this.rundown?.expectedStartTime

				if (!start) return undefined

				const date = new Date(start)
				return `${date.getHours()}:${date.getMinutes()}:${date.getSeconds()}`
			},
			set(time: string) {
				if (!this.editObject) {
					this.editObject = {
						...this.rundown
					}
				}
				if (!time) {
					Vue.set(this.editObject, 'expectedStartTime', null)
				} else {
					Vue.set(
						this.editObject,
						'expectedStartTime',
						new Date(this.startDate + ' ' + time).getTime()
					)
				}
			}
		},
		endDate: {
			get(): string | undefined {
				const start = this.editObject
					? this.editObject.expectedEndTime
					: this.rundown?.expectedEndTime
				if (!start) return undefined

				const date = new Date(start)
				return `${date.getFullYear()}-${date.getMonth() + 1}-${date.getDate()}`
			},
			set(date: string) {
				if (!this.editObject) {
					this.editObject = {
						...this.rundown
					}
				}

				if (!date) {
					Vue.set(this.editObject, 'expectedEndTime', null)
				} else {
					Vue.set(
						this.editObject,
						'expectedEndTime',
						new Date(date + ' ' + (this.startTime || '00:00:00')).getTime()
					)
				}
			}
		},
		endTime: {
			get(): string | undefined {
				const start = this.editObject
					? this.editObject.expectedEndTime
					: this.rundown?.expectedEndTime

				if (!start) return undefined

				const date = new Date(start)
				return `${date.getHours()}:${date.getMinutes()}:${date.getSeconds()}`
			},
			set(time: string) {
				if (!this.editObject) {
					this.editObject = {
						...this.rundown
					}
				}
				if (!time) {
					Vue.set(this.editObject, 'expectedEndTime', null)
				} else {
					Vue.set(
						this.editObject,
						'expectedEndTime',
						new Date(this.startDate + ' ' + time).getTime()
					)
				}
			}
		},
		metaDataManifest() {
			return store.state.settings.rundownMetadata
		},
		labelOnUpdateButton(): string {
			return this.rundown.sync ? 'Update' : 'Save'
		}
	},
	data() {
		return {
			editObject: undefined as
				| (Partial<Omit<Rundown, 'metaData'>> & { metaData?: Nullable<Rundown['metaData']> })
				| undefined
		}
	},
	methods: {
		reset() {
			this.editObject = undefined
		},
		deleteRundown() {
			store.dispatch('removeRundown', this.id)
			this.$router.push('/')
		},
		update() {
			if (this.editObject) {
				store.dispatch('updateRundown', { ...this.editObject })
			}
		},
		updateMetaData(field: string, value: string | number | boolean | null) {
			if (!this.editObject) {
				this.editObject = {
					...this.rundown
				}
			}
			if (!this.editObject['metaData']) {
				this.editObject.metaData = {}
			}
			if (value === undefined || value === '') value = null
			this.editObject.metaData[field] = value
		},
		async exportRundown() {
			const rundown = this.rundown as Rundown
			if (!rundown.id) {
				return
			}

			if (typeof rundown.sync !== 'boolean') {
				rundown.sync = false
			}

			const segments = await ipcRenderer.invoke(
				'segments',
				literal<IpcOperation>({
					type: IpcOperationType.Read,
					payload: {
						rundownId: rundown.id
					}
				})
			)

			const parts = await ipcRenderer.invoke(
				'parts',
				literal<IpcOperation>({
					type: IpcOperationType.Read,
					payload: {
						rundownId: rundown.id
					}
				})
			)

			const pieces = await ipcRenderer.invoke(
				'pieces',
				literal<IpcOperation>({
					type: IpcOperationType.Read,
					payload: {
						rundownId: rundown.id
					}
				})
			)

			saveToFile({
				title: 'Export rundown',
				document: literal<SerializedRundown>({
					rundown,
					segments,
					parts,
					pieces
				})
			})
		}
	}
})
</script>
⋮----
<style scoped>
.rundown-editor {
	padding: 2em;
}

.form-group {
	margin: 0.5em 0;
}

.buttons {
	margin: 1em 0;
}

.export-button {
	margin: 0 1em;
}
</style>

================
File: components/rundown/RundownFooter.vue
================
<template>
	<div class="footer">
		<b-breadcrumb :items="items"></b-breadcrumb>
	</div>
</template>
⋮----
<script lang="ts">
import store from '@/store'
import Vue from 'vue'

export default Vue.extend({
	computed: {
		items() {
			const rundownid = this.$route.params.id
			const rundown = store.state.rundowns.find((r) => r.id === rundownid)

			const pieceId = this.$route.params.piece
			const piece = pieceId && store.state.pieces.find((p) => p.id === pieceId)

			const partId = piece ? piece.partId : this.$route.params.part
			const part = partId && store.state.parts.find((p) => p.id === partId)

			const segmentId = part ? part.segmentId : this.$route.params.segment
			const segment = segmentId && store.state.segments.find((s) => s.id === segmentId)

			return [
				{
					text: rundown?.name,
					to: '/rundown/' + rundown?.id
				},
				segment && {
					text: segment.name,
					to: `/rundown/${rundownid}/segment/${segmentId}`
				},
				part && {
					text: part.name,
					to: `/rundown/${rundownid}/part/${partId}`
				},
				piece && {
					text: piece.name,
					to: `/rundown/${rundownid}/piece/${pieceId}`
				}
			].filter((item) => item)
		}
	}
})
</script>
⋮----
<style scoped>
.footer {
	background-color: #000;
	padding: 0.2em;
	font-size: 0.9em;
}
a {
	color: #bdbdbd;
}
.breadcrumb,
ol {
	margin-bottom: 0;
}
</style>

================
File: components/rundown/RundownHeader.vue
================
<template>
	<div class="header">
		<div class="name">
			<router-link :to="'/rundown/' + rundown.id">{{ rundown.name }}</router-link>
		</div>
		<div class="d-flex justify-content-between">
			<div class="d-grid timing">
				<div class="label">Expected start:</div>
				<div>{{ start }}</div>
				<div class="label">Expected duration:</div>
				<div>{{ duration }}</div>
				<div class="label">Diff:</div>
				<div>{{ diff }}</div>
			</div>
			<div>
				<router-link class="close" to="/">
					<fa icon="times" />
				</router-link>
			</div>
		</div>
	</div>
</template>
⋮----
<router-link :to="'/rundown/' + rundown.id">{{ rundown.name }}</router-link>
⋮----
<div>{{ start }}</div>
⋮----
<div>{{ duration }}</div>
⋮----
<div>{{ diff }}</div>
⋮----
<script lang="ts">
import { Rundown } from '@/background/interfaces'
import { toTime, toTimeDiff } from '@/util/lib'
import store from '@/store'
import Vue from 'vue'
export default Vue.extend({
	computed: {
		rundown(): Partial<Rundown> {
			return store.state.rundowns.find((r) => r.id === this.$route.params.id) || {}
		},
		start(): string {
			return this.rundown.expectedStartTime
				? new Date(this.rundown.expectedStartTime).toLocaleTimeString()
				: 'Not set'
		},
		duration(): string {
			if (!this.rundown.expectedStartTime || !this.rundown.expectedEndTime) {
				return 'Not set'
			}
			const t = this.rundown.expectedEndTime - this.rundown.expectedStartTime

			return toTime(t / 1000)
		},
		diff(): string {
			if (!this.rundown.expectedStartTime || !this.rundown.expectedEndTime) {
				return '-'
			}

			const expectedDuration = this.rundown.expectedEndTime - this.rundown.expectedStartTime
			const actualDuration = store.state.parts
				.filter((p) => p.rundownId === this.rundown.id && p.payload && p.payload.duration)
				.map((p) => p.payload.duration as number)
				.reduce((a, b) => a + b, 0)

			return toTimeDiff(actualDuration - expectedDuration / 1000)
		}
	}
})
</script>
⋮----
<style scoped>
.header {
	background-color: #2689ba;
	font-size: 1.2em;
}

a {
	color: white;
	text-decoration: none;
}
.close {
	font-size: 1.8em;
	padding: 0.2em 0.4em;
}
.name {
	line-height: 2.8em;
	height: 0;
	text-align: center;
}
.timing {
	display: grid;
	grid-template-columns: auto auto auto;
	grid-template-rows: auto auto;
	gap: 0 0.2em;
	grid-auto-flow: column;
}
.timing .label {
	font-size: 0.8em;
}
</style>

================
File: components/rundown/SegmentEditor.vue
================
<template>
	<div class="segment-editor d-flex flex-column">
		<h2>Segment</h2>
		<b-form @submit.prevent="update">
			<b-form-group label="Name:">
				<b-form-input v-model="name"></b-form-input>
			</b-form-group>

			<b-form-group label="Float:">
				<b-form-checkbox v-model="float"></b-form-checkbox>
			</b-form-group>
		</b-form>

		<div class="buttons d-flex flex-row justify-content-between">
			<b-button variant="danger" v-b-modal.delete-rd>Delete</b-button>
			<b-button-group>
				<b-button @click="reset">Cancel</b-button>
				<b-button type="submit" @click="update" variant="primary">{{ labelOnUpdateButton }}</b-button>
			</b-button-group>
		</div>

		<b-modal id="delete-rd" title="Delete segment" @ok="deleteRundown" ok-variant="danger" ok-title="Delete">
			<p class="my-4">Are you sure you want to delete "{{ segment.name }}?"</p>
		</b-modal>
	</div>
</template>
⋮----
<b-button type="submit" @click="update" variant="primary">{{ labelOnUpdateButton }}</b-button>
⋮----
<p class="my-4">Are you sure you want to delete "{{ segment.name }}?"</p>
⋮----
<script lang="ts">
import { Rundown, Segment } from '@/background/interfaces'
import store from '@/store'
import Vue from 'vue'

export default Vue.extend({
	computed: {
		id(): string {
			return this.$route.params.id
		},
		rundown: {
			get(): Partial<Rundown> {
				return { ...(store.state.rundowns.find((r) => r.id === this.id) || {}) }
			}
		},
		segment() {
			return store.state.segments.find((s) => s.id === this.$route.params.segment)
		},

		name: {
			get(): string | undefined {
				return this.editObject ? this.editObject.name : this.segment?.name
			},
			set(name: string) {
				if (!this.editObject) this.editObject = { ...this.segment }
				Vue.set(this.editObject, 'name', name)
			}
		},

		float: {
			get(): boolean | undefined {
				return this.editObject ? this.editObject.float : this.segment?.float
			},
			set(float: boolean) {
				if (!this.editObject) this.editObject = { ...this.segment }
				Vue.set(this.editObject, 'float', float)
			}
		},
		labelOnUpdateButton(): string {
			return this.rundown.sync ? 'Update' : 'Save'
		}
	},
	data() {
		return {
			editObject: undefined as Partial<Segment> | undefined
		}
	},
	methods: {
		reset() {
			this.editObject = undefined
		},
		deleteRundown() {
			store.dispatch('removeSegment', this.segment?.id)
			this.$router.push('/rundown/' + this.rundown.id)
		},
		update() {
			if (this.editObject) {
				store.dispatch('updateSegment', { ...this.editObject })
			}
		}
	},
	watch: {
		$route: function () {
			this.editObject = undefined
		}
	}
})
</script>
⋮----
<style scoped>
.segment-editor {
	padding: 2em;
}

.form-group {
	margin: 0.5em 0;
}

.buttons {
	margin: 1em 0;
}
</style>

================
File: components/rundown/SegmentList.vue
================
<template>
	<div class="segment-list d-flex flex-column">
		<draggable :list="sortableSegments" group="segments" @change="changeSegments">
			<div class="part-list d-flex flex-column" v-for="segment in segments" :key="segment.id">
				<router-link :to="`/rundown/${rundown.id}/segment/${segment.id}`"
					:class="classes('segment', { floated: segment.float })">
					{{ segment.name }}
					<span class="time">{{ displayTime(segment.duration) }}</span>
				</router-link>
				<draggable class="d-flex flex-column" :list="segment.parts.map((p) => p.id)"
					:group="partGroup(segment.id)" @change="(ev) => changeParts2(segment.id, ev)">
					<router-link :to="`/rundown/${rundown.id}/part/${part.id}`"
						:class="classes('part', { floated: segment.float || part.float, active: part.active })"
						v-for="part in segment.parts" :key="part.id">
						{{ part.name }}
						<span class="time">{{ displayTime(part.payload.duration) }}</span>
					</router-link>
				</draggable>
				<div class="part new" @click="newPart(segment.id)">New part</div>
			</div>
		</draggable>
		<div class="segment new" @click="newSegment">New segment</div>
	</div>
</template>
⋮----
{{ segment.name }}
<span class="time">{{ displayTime(segment.duration) }}</span>
⋮----
{{ part.name }}
<span class="time">{{ displayTime(part.payload.duration) }}</span>
⋮----
<script lang="ts">
import { Part, Rundown, Segment } from '@/background/interfaces'
import store from '@/store'
import Vue from 'vue'
import draggable from 'vuedraggable'

export default Vue.extend({
	components: { draggable },
	computed: {
		rundown(): Rundown | undefined {
			return store.state.rundowns.find((r) => r.id === this.$route.params.id) || undefined
		},
		segments() {
			const pieceId = this.$route.params.piece
			const piece = pieceId && store.state.pieces.find((p) => p.id === pieceId)

			const activePartId = piece ? piece.partId : this.$route.params.part

			// todo filter for rundown id
			return store.state.segments
				.map((segment) => ({
					...segment,
					duration: store.state.parts
						.filter((p) => p.segmentId === segment.id)
						.map((p) => p.payload?.duration || 0)
						.reduce((a, b) => a + b, 0),
					parts: store.state.parts
						.filter((p) => p.segmentId === segment.id)
						.sort((a, b) => (a.rank || 0) - (b.rank || 0))
						.map((p) => ({
							...p,
							payload: p.payload || {},
							active: p.id === activePartId
						}))
				}))
				.sort((a, b) => (a.rank || 0) - (b.rank || 0))
		},
		sortableSegments: {
			get() {
				return store.state.segments
					.sort((a, b) => (a.rank || 0) - (b.rank || 0))
					.map((segment) => segment.id)
			}
		}
	},
	data() {
		return {
			lastPartListMutation: undefined as
				| {
					segmentId: string
					partId: string
					index: number
					futureIndex: number
				}
				| undefined
		}
	},
	methods: {
		newSegment() {
			if (this.rundown)
				store.dispatch('newSegment', {
					playlistId: this.rundown.playlistId,
					rundownId: this.rundown.id,
					rank: this.segments.length
				})
		},
		newPart(id: string) {
			const segment = this.segments.find((s) => id === s.id)
			if (this.rundown)
				store.dispatch('newPart', {
					playlistId: this.rundown.playlistId,
					rundownId: this.rundown.id,
					segmentId: id,
					rank: segment?.parts.length || 0
				})
		},

		displayTime(seconds: number) {
			if (!seconds) return

			const h = Math.floor(seconds / 3600)
			const m = Math.floor((seconds % 3600) / 60)
			const s = Math.floor(seconds % 60)
			const pad = (t: number) => ('00' + t).substr(-2)

			return `${h > 0 ? pad(h) + ':' : ''}${pad(m)}:${pad(s)}`
		},

		classes(name: string, conditionals: Record<string, boolean>) {
			return {
				[name]: true,
				...conditionals
			}
		},

		partGroup(id: string) {
			return {
				name: id,
				pull: store.state.segments.map((p) => p.id),
				put: store.state.segments.map((p) => p.id)
			}
		},

		// eslint-disable-next-line @typescript-eslint/no-explicit-any
		changeParts2(segmentId: string, ev: any) {
			const segment = this.segments.find((s) => s.id === segmentId)
			if (!segment) return

			if ('moved' in ev) {
				const { oldIndex, newIndex, element: id } = ev.moved
				const delta = oldIndex > newIndex ? 1 : -1
				const partsToUpdate = segment.parts
					.filter(
						(_, i) =>
							(delta > 0 && i < oldIndex && i >= newIndex) ||
							(delta < 0 && i > oldIndex && i <= newIndex)
					)
					.map(
						(s): Partial<Part> => ({
							id: s.id,
							rundownId: s.rundownId,
							segmentId: s.segmentId,
							rank: s.rank + delta
						})
					)

				store.dispatch('updatePart', {
					id,
					rundownId: this.rundown?.id,
					segmentId: segment.id,
					rank: newIndex
				})
				partsToUpdate.forEach((p) => {
					store.dispatch('updatePart', p)
				})
			} else if ('added' in ev) {
				const { newIndex, element: id } = ev.added

				const partsToUpdate = segment.parts
					.filter((p) => p.rank >= newIndex)
					.map((p) => ({
						id: p.id,
						rundownId: p.rundownId,
						segmentId: p.segmentId,
						rank: p.rank + 1
					}))

				store.dispatch('updatePart', {
					id,
					rundownId: this.rundown?.id,
					segmentId: segment.id,
					rank: newIndex
				})
				partsToUpdate.forEach((p) => {
					store.dispatch('updatePart', p)
				})
			} else if ('removed' in ev) {
				const { oldIndex } = ev.added

				const partsToUpdate = segment.parts
					.filter((p) => p.rank > oldIndex)
					.map((p) => ({
						id: p.id,
						rundownId: p.rundownId,
						segmentId: p.segmentId,
						rank: p.rank - 1
					}))

				partsToUpdate.forEach((p) => {
					store.dispatch('updatePart', p)
				})
			}
		},
		// eslint-disable-next-line @typescript-eslint/no-explicit-any
		changeSegments(ev: any) {
			if ('moved' in ev) {
				const { oldIndex, newIndex, element: id } = ev.moved
				const delta = oldIndex > newIndex ? 1 : -1
				const segmentsToUpdate = this.segments
					.filter(
						(_, i) =>
							(delta > 0 && i < oldIndex && i >= newIndex) ||
							(delta < 0 && i > oldIndex && i <= newIndex)
					)
					.map(
						(s): Partial<Segment> => ({
							id: s.id,
							rank: s.rank + delta
						})
					)

				store.dispatch('updateSegment', {
					id,
					rank: newIndex
				})
				segmentsToUpdate.forEach((s) => {
					store.dispatch('updateSegment', s)
				})
			}
		}
	}
})
</script>
⋮----
<style scoped>
.segment-list {
	width: 300px;
}

a {
	color: white;
	text-decoration: none;
}

.segment {
	background-color: #4b4b4b;
	width: 100%;
	font-size: 1.2em;
	line-height: 2em;
	height: 2.4em;
	padding: 0.2em;
}

.new {
	color: #777;
}

.new:hover {
	color: white;
	cursor: pointer;
}

.part-list div {
	min-height: 1px;
}

.part {
	margin-top: 2px;
	background-color: #353535;
	margin-left: 15px;
	width: calc(100% - 15px);
	font-size: 1em;
	line-height: 1.5em;
	height: 1.8em;
	padding: 0.2em;
}

.part:hover {
	background-color: #777;
}

/* Keep the "New part" button aligned with other parts */
.part.new {
	margin-left: 15px;
	margin-bottom: 8px;
	margin-top: 2px;
}

/* Add a subtle background to make the hierarchy more visible */
.part-list {
	background-color: rgba(0, 0, 0, 0.2);
}

.time {
	font-size: 0.7em;
	color: #b2b2b2;
}

.floated {
	text-decoration: line-through;
}

.active,
.router-link-active {
	border: 1px solid #009dff;
}
</style>

================
File: components/settings/AppSettings.vue
================
<template>
	<div class="app-settings">
		<h2>Settings</h2>

		<div>
			<label for="coreUrl">Core connection:</label>
			<input type="text" placeholder="Core URL" name="coreUrl" v-model="coreUrl" />

			<input type="number" placeholder="Core Port" name="corePort" v-model="corePort" />
		</div>

		<div>
			<label for="id">Part types:</label>
			<input type="text" name="id" v-model="partTypes" />
		</div>

		<div>
			<h4>Rundown Metadata Fields:</h4>

			<div class="field-editor" v-for="(field, i) in rundownMetadata" :key="i">
				<label for="id">Field ID:</label>
				<input type="text" name="id" v-model="field.id" @click="createEditObj" />

				<label for="label">Label:</label>
				<input type="text" name="label" v-model="field.label" @click="createEditObj" />

				<label for="type">Type:</label>
				<select name="type" id="type" v-model="field.type" @change="createEditObj">
					<option v-for="(type, entry) in fieldTypes" :key="type" :value="type">{{ entry }}</option>
				</select>

				<span class="link" @click="() => removeField(field.id)"><fa icon="trash" /></span>
			</div>
			<b-button variant="primary" @click="() => newField()">+</b-button>
		</div>

		<div class="buttons d-flex flex-row">
			<b-button-group>
				<b-button @click="reset">Cancel</b-button>
				<b-button @click="update" variant="primary">Save</b-button>
			</b-button-group>
		</div>
	</div>
</template>
⋮----
<option v-for="(type, entry) in fieldTypes" :key="type" :value="type">{{ entry }}</option>
⋮----
<script lang="ts">
import { ApplicationSettings, ManifestFieldType } from '@/background/interfaces'
import { editField } from '@/util/lib'
import store from '@/store'
import Vue from 'vue'

type EditApplicationSettings = Omit<ApplicationSettings, 'partTypes'> & { partTypes: string }

export default Vue.extend({
	computed: {
		settings(): EditApplicationSettings {
			return {
				...store.state.settings,
				partTypes: store.state.settings.partTypes.join(', ')
			}
		},
		...editField('settings', 'coreUrl'),
		...editField('settings', 'corePort'),
		...editField('settings', 'partTypes'),
		...editField('settings', 'rundownMetadata')
	},
	data() {
		return {
			editObject: undefined as EditApplicationSettings | undefined,
			fieldTypes: ManifestFieldType
		}
	},
	methods: {
		createEditObj() {
			if (!this.editObject) {
				this.editObject = {
					...this.settings,
					rundownMetadata: [...(this.settings.rundownMetadata || [])]
				}
			}
		},
		removeField(id: string) {
			if (!this.editObject) {
				this.editObject = {
					...this.settings,
					rundownMetadata: [...(this.settings.rundownMetadata || [])]
				}
			}
			if (!this.editObject?.rundownMetadata) {
				this.editObject.rundownMetadata = [...(this.settings?.rundownMetadata || [])]
			}

			this.editObject.rundownMetadata = this.editObject?.rundownMetadata.filter((m) => m.id !== id)
		},
		newField() {
			if (!this.editObject) {
				this.editObject = {
					...this.settings,
					rundownMetadata: [...(this.settings.rundownMetadata || [])]
				}
			}
			if (!this.editObject?.rundownMetadata) {
				this.editObject.rundownMetadata = [...(this.settings?.rundownMetadata || [])]
			}

			this.editObject.rundownMetadata.push({ id: '', label: '', type: ManifestFieldType.String })
		},
		reset() {
			this.editObject = undefined
		},
		update() {
			if (this.editObject) {
				store.dispatch('updateSettings', {
					...this.editObject,
					partTypes: this.editObject.partTypes.split(',').map((type) => type.trim())
				})
			}
		}
	}
})
</script>
⋮----
<style scoped>
.app-settings div {
	margin: 0.2em 0;
}
.field-editor {
	display: flex;
	align-items: center;
}
.field-editor input {
	flex-grow: 1;
}
.link {
	cursor: pointer;
}
</style>

================
File: components/settings/PieceType.vue
================
<template>
	<div class="type-editor">
		<h4>Piece Manifest:</h4>
		<b-form @submit.prevent="update">
		<div>
			<label for="id">ID:</label>
			<input type="text" name="id" v-model="id" />
		</div>

		<div>
			<label for="name">Name:</label>
			<input type="text" name="name" v-model="name" />
		</div>

		<div>
			<label for="shortName">Short Name:</label>
			<input type="text" name="shortName" v-model="shortName" />
		</div>

		<div>
			<label for="colour">Colour:</label>
			<input type="text" name="colour" v-model="colour" />
		</div>

		<div>
			<label for="includeTypeInName">Include in name:</label>
			<input type="checkbox" name="includeTypeInName" v-model="includeTypeInName" />
		</div>

		<div>
			<h4>Fields:</h4>

			<div class="field-editor" v-for="(field, i) in payload" :key="i">
				<label for="id">Field ID:</label>
				<input type="text" name="id" v-model="field.id" @click="createEditObj" />

				<label for="label">Label:</label>
				<input type="text" name="label" v-model="field.label" @click="createEditObj" />

				<label for="type">Type:</label>
				<select name="type" id="type" v-model="field.type" @change="createEditObj">
					<option v-for="(type, entry) in fieldTypes" :key="type" :value="type">{{ entry }}</option>
				</select>

				<label for="includeInName">Include in name:</label>
				<input
					type="checkbox"
					name="includeInName"
					v-model="field.includeInName"
					@click="createEditObj"
				/>

				<span class="link" @click="() => removeField(field.id)"><fa icon="trash" /></span>
			</div>
			<b-button variant="primary" @click="() => newField()">+</b-button>
		</div>

		<div class="buttons d-flex flex-row justify-content-end">
			<b-button-group>
				<b-button @click="reset">Cancel</b-button>
				<b-button type="submit" @click="update" variant="primary">Save</b-button>
			</b-button-group>
		</div>
		</b-form>
	</div>
</template>
⋮----
<option v-for="(type, entry) in fieldTypes" :key="type" :value="type">{{ entry }}</option>
⋮----
<script lang="ts">
import { ManifestFieldType, PieceTypeManifest } from '@/background/interfaces'
import { editField } from '@/util/lib'
import store from '@/store'
import Vue from 'vue'

export default Vue.extend({
	props: {
		manifestId: String
	},
	computed: {
		item(): Partial<PieceTypeManifest> {
			const item = store.state.piecesManifest.find((m) => m.id === this.manifestId)

			return item || {}
		},
		...editField('item', 'id'),
		...editField('item', 'name'),
		...editField('item', 'shortName'),
		...editField('item', 'colour'),
		...editField('item', 'includeTypeInName'),
		...editField('item', 'payload')
	},
	data() {
		return {
			editObject: undefined as Partial<PieceTypeManifest> | undefined,
			fieldTypes: ManifestFieldType
		}
	},
	methods: {
		createEditObj() {
			if (!this.editObject) {
				this.editObject = {
					...this.item,
					payload: (this.item.payload || []).map((item) => ({ ...item }))
				}
			}
		},
		reset() {
			this.editObject = undefined
		},
		update() {
			if (this.editObject) {
				store.dispatch('updatePieceTypeManifest', { update: this.editObject, id: this.manifestId })
			}
		},
		newField() {
			if (!this.editObject) {
				this.editObject = {
					...this.item,
					payload: [...(this.item.payload || [])]
				}
			}
			if (!this.editObject.payload) {
				this.editObject.payload = [...(this.item.payload || [])]
			}
			const count = this.editObject.payload.filter((f) => f.id.startsWith('new')).length

			this.editObject.payload.push({
				id: 'new' + count,
				label: 'New field',
				type: ManifestFieldType.String
			})
		},
		removeField(id: string) {
			if (!this.editObject) {
				this.editObject = {
					...this.item,
					payload: [...(this.item.payload || [])]
				}
			}
			if (!this.editObject.payload) {
				this.editObject.payload = [...(this.item.payload || [])]
			}

			this.editObject.payload = this.editObject.payload.filter((f) => f.id !== id)
		}
	}
})
</script>
⋮----
<style scoped>
.type-editor {
	padding: 0.5em;
}
.type-editor div {
	margin: 0.2em 0;
}
.field-editor {
	display: flex;
	align-items: center;
}
.field-editor input {
	flex-grow: 1;
}
.link {
	cursor: pointer;
}
</style>

================
File: components/settings/PieceTypes.vue
================
<template>
	<div>
		<div class="piece-types">
			<div class="buttons d-flex flex-row justify-content-between">
				<h2>Piece types</h2>

				<b-button-group>
					<b-button @click="importPieceTypes">Import</b-button>
					<b-button @click="exportPieceTypes">Export</b-button>
				</b-button-group>
			</div>

			<div class="type" v-for="type in types" :key="type.id">
				<div class="header">
					<div class="colour-preview" :style="{ backgroundColor: type.colour }"></div>
					<div class="name">{{ type.name }}</div>
					<div>
						<span class="link" @click="() => toggleDetails(type.id)"><fa icon="pencil-alt" /></span>
						<span class="link" @click="() => removePieceType(type.id)"><fa icon="trash" /></span>
					</div>
				</div>
				<div v-if="type._showDetails" :class="className('body', {})">
					<piece-type :manifestId="type.id" />
				</div>
			</div>
			<b-button variant="" @click="newPieceType">New piece type</b-button>
		</div>
	</div>
</template>
⋮----
<div class="name">{{ type.name }}</div>
⋮----
<script lang="ts">
import { PieceTypeManifest } from '@/background/interfaces'
import store from '@/store'
import Vue from 'vue'
import PieceType from './PieceType.vue'
import { openFromFile, saveToFile } from '@/util/fs'

export default Vue.extend({
	components: { PieceType },
	computed: {
		types(): Array<PieceTypeManifest & { _showDetails: boolean }> {
			return store.state.piecesManifest.map((piece) => ({
				...piece,
				_showDetails: this.showDetails.includes(piece.id)
			}))
		},
		pieceTypes() {
			return store.state.piecesManifest
		}
	},
	data() {
		return {
			showDetails: [] as string[]
		}
	},
	methods: {
		toggleDetails(id: string) {
			if (this.showDetails.includes(id)) {
				this.showDetails.splice(this.showDetails.indexOf(id), 1)
			} else {
				this.showDetails.push(id)
			}
		},
		className(name: string, fields: Record<string, boolean>) {
			return {
				[name]: true,
				...fields
			}
		},
		newPieceType() {
			store.dispatch('newPieceTypeManifest')
		},
		removePieceType(id: string) {
			store.dispatch('removePieceTypeManifest', id)
		},

		exportPieceTypes() {
			saveToFile({ title: 'Export piece types', document: this.pieceTypes })
		},

		async importPieceTypes() {
			const pieceTypes = await openFromFile({ title: 'Import piece types' })
			// eslint-disable-next-line @typescript-eslint/no-explicit-any
			const verify = (pieceTypes: any) =>
				Array.isArray(pieceTypes) &&
				pieceTypes.map((t) => 'id' in t && 'name' in t && 'payload' in t).filter((p) => p === false)

			if (verify(pieceTypes)) {
				pieceTypes.forEach((p: PieceTypeManifest) => {
					const existing = this.pieceTypes.find((type) => type.id === p.id)

					if (existing) {
						store.dispatch('updatePieceTypeManifest', p)
					} else {
						store.dispatch('importPieceTypeManifest', p)
					}
				})
			}
		}
	}
})
</script>
⋮----
<style scoped>
.piece-types {
	width: 100%;
	display: flex;
	flex-direction: column;
}
.type {
	width: 100%;
}
.header {
	width: 100%;
	display: flex;
	flex-direction: row;
	align-items: center;
	height: 2.5em;
	border-top: 1px solid #888;
	border-bottom: 1px solid #888;
}
.header .name {
	flex-grow: 1;
	margin: 0 0.2em;
}
/* .body {
	visibility: hidden;
}
.body.visible {
	visibility: visible;
} */
.colour-preview {
	width: 30px;
	height: 30px;
	border-radius: 3px;
}
.link {
	cursor: pointer;
	margin-left: 0.2em;
}
.buttons {
	margin-bottom: 1em;
}
</style>

================
File: components/AppHeader.vue
================
<template>
	<div class="app-header d-flex justify-content-between">
		<div class="d-flex align-items-center">
			<div class="logo"></div>
			<div>Core Connection Status: {{ status }}</div>
		</div>
		<div>
			<router-link to="/">Rundowns</router-link>
			<router-link to="/settings">Settings</router-link>
		</div>
	</div>
</template>
⋮----
<div>Core Connection Status: {{ status }}</div>
⋮----
<script lang="ts">
import store from '@/store'
import Vue from 'vue'
import { CoreConnectionStatus } from '../background/interfaces'

export default Vue.extend({
	computed: {
		status() {
			const host = store.state.coreConnectionInfo.url || '127.0.0.1'
			const port = store.state.coreConnectionInfo.port || 3000
			const hostPortString = `${host}:${port}`
			if (store.state.coreConnectionInfo.status === CoreConnectionStatus.CONNECTED) {
				return `${store.state.coreConnectionInfo.status} to ${hostPortString}`
			}

			return `${store.state.coreConnectionInfo.status} from ${hostPortString}`
		}
	}
})
</script>
⋮----
<style scoped>
a {
	color: white;
	line-height: 3.5em;
	margin: 0 0.5em;
	text-decoration: none;
}
a:hover {
	text-decoration: underline;
}
.app-header {
	background: black;
}
.logo {
	margin: 0.5em;
	width: 2.5em;
	height: 2.5em;
	background-image: url(../assets/sofie-logo.svg);
	background-repeat: no-repeat;
}
</style>

================
File: components/PlaylistList.vue
================
<template>
	<div>
		<b-list-group>
			<b-list-group-item
				v-for="playlist in playlists"
				:key="playlist.id"
				href="#"
				class="d-flex justify-content-between align-items-center"
				:to="'/playlist/' + playlist.id"
			>
				{{ playlist.name }}
				<b-button v-b-modal.edit-playlist @click="setEditPlaylist(playlist.id)"> edit </b-button>
			</b-list-group-item>
		</b-list-group>

		<b-modal id="edit-playlist" title="Edit playlist" @hide="close">
			<b-form-input v-model="newPlaylistName" placeholder="Name..."></b-form-input>

			<template #modal-footer>
				<b-button variant="danger" @click="removePlaylist">Delete</b-button>
				<b-button variant="" @click="close">Cancel</b-button>
				<b-button variant="primary" @click="updatePlaylist">Save</b-button>
			</template>
		</b-modal>
	</div>
</template>
⋮----
{{ playlist.name }}
⋮----
<template #modal-footer>
				<b-button variant="danger" @click="removePlaylist">Delete</b-button>
				<b-button variant="" @click="close">Cancel</b-button>
				<b-button variant="primary" @click="updatePlaylist">Save</b-button>
			</template>
⋮----
<script lang="ts">
import Vue from 'vue'
import store from '../store'

export default Vue.extend({
	components: {},
	computed: {
		playlists() {
			return store.state.playlists.map((p) => ({
				...p,
				rundowns: store.state.rundowns.filter((r) => r.playlistId === p.id)
			}))
		}
	},
	data() {
		return {
			newPlaylistName: '',
			editPlaylistId: ''
		}
	},
	methods: {
		setEditPlaylist(id: string) {
			const pl = this.playlists.find((p) => p.id === id)
			this.editPlaylistId = id
			this.newPlaylistName = pl?.name || ''
		},
		removePlaylist() {
			store.dispatch('removePlaylist', this.editPlaylistId)
			this.editPlaylistId = ''
			this.newPlaylistName = ''
			this.$bvModal.hide('edit-playlist')
		},
		close() {
			this.editPlaylistId = ''
			this.newPlaylistName = ''
			this.$bvModal.hide('edit-playlist')
		},
		updatePlaylist() {
			store.dispatch('updatePlaylist', {
				id: this.editPlaylistId,
				name: this.newPlaylistName
			})
			this.editPlaylistId = ''
			this.newPlaylistName = ''
			this.$bvModal.hide('edit-playlist')
		}
	}
})
</script>

================
File: router/index.ts
================
import VueRouter from 'vue-router'
⋮----
import Home from '../views/HomeView.vue'
import Playlist from '../views/PlaylistView.vue'
import Rundown from '../views/RundownView.vue'
import Settings from '../views/SettingsView.vue'
⋮----
import Header from '../components/AppHeader.vue'
import RundownEditor from '../components/rundown/RundownEditor.vue'
import SegmentEditor from '../components/rundown/SegmentEditor.vue'
import PartEditor from '../components/rundown/PartEditor.vue'
import PieceList from '../components/rundown/PieceList.vue'
import PieceEditor from '../components/rundown/PieceEditor.vue'

================
File: store/modules/playlists.ts
================
import { Playlist, IpcOperation, IpcOperationType } from '@/background/interfaces'
import { literal } from '@/util/lib'
import Vue from 'vue'
import { Module } from 'vuex'
import { State } from '..'
⋮----
export interface PlaylistsState {
	playlists: Playlist[]
}
⋮----
// state.playlists.splice(i, 1, playlist)

================
File: store/index.ts
================
import {
	IpcOperation,
	IpcOperationType,
	Part,
	Piece,
	PiecesManifest,
	PieceTypeManifest,
	Playlist,
	Rundown,
	Segment,
	ApplicationSettings,
	CoreConnectionStatus,
	CoreConnectionInfo,
	MutationRundownCreate,
	SerializedRundown,
	MutationSegmentCreate,
	MutationPartCreate,
	MutationPieceCreate
} from '@/background/interfaces'
import { PIECES_MANIFEST } from '@/background/manifest'
import { literal } from '@/util/lib'
import Vue from 'vue'
import Vuex from 'vuex'
⋮----
export interface State {
	playlists: Playlist[]
	rundowns: Rundown[]
	segments: Segment[]
	parts: Part[]
	pieces: Piece[]
	piecesManifest: PiecesManifest
	settings: ApplicationSettings
	coreConnectionInfo: CoreConnectionInfo
}
⋮----
export enum Actions {}
⋮----
// state.playlists.splice(i, 1, playlist)
⋮----
// state.playlists.splice(i, 1, playlist)
⋮----
// state.playlists.splice(i, 1, playlist)
⋮----
// state.playlists.splice(i, 1, playlist)
⋮----
// state.playlists.splice(i, 1, playlist)
⋮----
// state.pieceTypeManifests.splice(i, 1, pieceTypeManifest)
⋮----
// In the actions section of the store, add:
⋮----
// Call the backend reset function
⋮----
// Update the store with the new settings
⋮----
// Reset PieceTypeManifests:
⋮----
export async function initStore()

================
File: types/smpte-timecode.d.ts
================
declare function Timecode(
declare interface TimecodeObject {
	frameCount: number
	frameRate: number
	hours: number
	minutes: number
	seconds: number
	frames: number
	dropFrame: number

	add: (x: number | Date | TimecodeObject) => void
	subtract: (x: number | Date | TimecodeObject) => void

	toString: () => string
	toString: (fields: 'field') => string
	toDate: () => Date
	valueOf: () => number
}

================
File: util/fs.ts
================
/**
 * This implementation is a fast and dirty way of opening and saving files HOWEVER,
 * this uses the electron remote API which is not a good practice. Ideally this
 * implementation will be replace to use native HTML API's so everything works from
 * the browser sandbox.
 */
⋮----
export interface SaveToFileArgs {
	title: string
	document: unknown
}
⋮----
export async function saveToFile(args: SaveToFileArgs): Promise<boolean>
⋮----
export interface OpenFromFileArgs {
	title: string
}
⋮----
// eslint-disable-next-line @typescript-eslint/no-explicit-any
export async function openFromFile(args: OpenFromFileArgs): Promise<boolean | any>

================
File: util/lib.ts
================
export function literal<T>(o: T)
⋮----
export type Nullable<T> = { [K in keyof T]: T[K] | null }
⋮----
/* eslint-disable @typescript-eslint/no-explicit-any */
// eslint-disable-next-line @typescript-eslint/no-unnecessary-type-constraint
export const editField = <T extends any>(
	doc: string,
	field: string,
	index?: string,
	defaultVal: any = undefined
) => (
⋮----
get(): T | undefined
set(value: T)
⋮----
/* eslint-enable @typescript-eslint/no-explicit-any */
⋮----
export const toTime = (seconds: number) =>
⋮----
const pad = (t: number)
⋮----
export const toTimeDiff = (seconds: number) =>

================
File: views/HomeView.vue
================
<template>
	<div class="home">
		<div class="d-flex justify-content-between align-items-center">
			<h2>Home</h2>
			<div class="d-flex">
				<b-button @click="newRundown" class="m-2">New</b-button>
				<b-button @click="importRundown" class="m-2">Import</b-button>
			</div>
			<!-- <b-dropdown split text="New rundown" @click="newRundown" class="m-2">
				<b-dropdown-item href="#" v-b-modal.new-playlist>New playlist</b-dropdown-item>
			</b-dropdown> -->
		</div>

		<playlist-list />

		<b-list-group>
			<b-list-group-item
				v-for="rundown in rundowns"
				:key="rundown.id"
				href="#"
				:to="'/rundown/' + rundown.id"
			>
				{{ rundown.name }}
			</b-list-group-item>
		</b-list-group>

		<b-modal id="new-playlist" title="Create new playlist" ok-title="Create" @ok="newPlaylist">
			<b-form-input v-model="newPlaylistName" placeholder="Name..."></b-form-input>
		</b-modal>

		<b-modal id="rundown-import-already-exists" title="Rundown Import Error" ok-only>
			ERROR: A rundown with that ID already exists.
		</b-modal>

		<b-modal id="rundown-import-is-invalid" title="Rundown Import Error" ok-only>
			ERROR: The selected file is not a valid rundown.
		</b-modal>
	</div>
</template>
⋮----
<!-- <b-dropdown split text="New rundown" @click="newRundown" class="m-2">
				<b-dropdown-item href="#" v-b-modal.new-playlist>New playlist</b-dropdown-item>
			</b-dropdown> -->
⋮----
{{ rundown.name }}
⋮----
<script lang="ts">
import Vue from 'vue'
import store from '../store'
import PlaylistList from '../components/PlaylistList.vue'
import { Playlist, Rundown, SerializedRundown } from '@/background/interfaces'
import { openFromFile } from '@/util/fs'

export default Vue.extend({
	name: 'App',
	components: {
		PlaylistList
	},
	computed: {
		playlists(): (Playlist & { rundowns: Rundown[] })[] {
			return store.state.playlists.map((p) => ({
				...p,
				rundowns: store.state.rundowns.filter((r) => r.playlistId === p.id)
			}))
		},
		editPlaylistItem(): Partial<Playlist & { rundowns: Rundown[] }> {
			return store.state.playlists.find((p) => p.id === this.editPlaylistId) || {}
		},

		rundowns() {
			return store.state.rundowns.filter((r) => !r.playlistId)
		}
	},
	data(): {
		editPlaylistId: string
		newPlaylistName: string
	} {
		return {
			newPlaylistName: '',
			editPlaylistId: ''
		}
	},
	methods: {
		newPlaylist() {
			store.dispatch('newPlaylist', { name: this.newPlaylistName })
		},

		newRundown() {
			store.dispatch('newRundown', {})
		},

		async importRundown() {
			let rundown: unknown
			try {
				rundown = await openFromFile({ title: 'Import rundown' })
			} catch (error) {
				// eslint-disable-next-line no-console
				console.error(error)
				this.$bvModal.show('rundown-import-is-invalid')
				return
			}

			// eslint-disable-next-line @typescript-eslint/no-explicit-any
			const verify = (maybeRundown: any): maybeRundown is SerializedRundown => {
				const rundownValid =
					typeof maybeRundown === 'object' &&
					maybeRundown !== null &&
					'rundown' in maybeRundown &&
					typeof maybeRundown.rundown === 'object' &&
					maybeRundown.rundown !== null &&
					'name' in maybeRundown.rundown &&
					typeof maybeRundown.rundown.name === 'string' &&
					'id' in maybeRundown.rundown &&
					typeof maybeRundown.rundown.id === 'string' &&
					'playlistId' in maybeRundown.rundown &&
					(typeof maybeRundown.rundown.playlistId === 'string' ||
						maybeRundown.rundown.playlistId === null) &&
					'sync' in maybeRundown.rundown &&
					typeof maybeRundown.rundown.sync === 'boolean' &&
					'segments' in maybeRundown &&
					Array.isArray(maybeRundown.segments) &&
					'parts' in maybeRundown &&
					Array.isArray(maybeRundown.parts) &&
					'pieces' in maybeRundown &&
					Array.isArray(maybeRundown.pieces)

				if (!rundownValid) {
					return false
				}

				const rd = maybeRundown as Pick<SerializedRundown, 'rundown'> & {
					segments: unknown[]
					parts: unknown[]
					pieces: unknown[]
				}

				/* eslint-disable @typescript-eslint/no-explicit-any */
				const segmentsValid = rd.segments.every((segment: any) => {
					return (
						typeof segment === 'object' &&
						segment !== null &&
						'name' in segment &&
						typeof segment.name === 'string' &&
						'rank' in segment &&
						typeof segment.rank === 'number' &&
						'id' in segment &&
						typeof segment.id === 'string' &&
						'rundownId' in segment &&
						typeof segment.rundownId === 'string' &&
						'playlistId' in segment &&
						(typeof segment.playlistId === 'string' || segment.playlistId === null)
					)
				})

				const partsValid = rd.parts.every((part: any) => {
					return (
						typeof part === 'object' &&
						part !== null &&
						'name' in part &&
						typeof part.name === 'string' &&
						'rank' in part &&
						typeof part.rank === 'number' &&
						'id' in part &&
						typeof part.id === 'string' &&
						'rundownId' in part &&
						typeof part.rundownId === 'string' &&
						'playlistId' in part &&
						(typeof part.playlistId === 'string' || part.playlistId === null)
					)
				})

				const piecesValid = rd.pieces.every((piece: any) => {
					return (
						typeof piece === 'object' &&
						piece !== null &&
						'name' in piece &&
						typeof piece.name === 'string' &&
						'id' in piece &&
						typeof piece.id === 'string' &&
						'rundownId' in piece &&
						typeof piece.rundownId === 'string' &&
						'playlistId' in piece &&
						(typeof piece.playlistId === 'string' || piece.playlistId === null)
					)
				})

				return segmentsValid && partsValid && piecesValid
			}

			if (verify(rundown)) {
				const actuallyRundown = rundown as SerializedRundown
				const existing = this.rundowns.find((rd) => rd.id === actuallyRundown.rundown.id)
				if (existing) {
					this.$bvModal.show('rundown-import-already-exists')
				} else {
					store.dispatch('importRundown', actuallyRundown)
				}
			} else {
				this.$bvModal.show('rundown-import-is-invalid')
			}
		}
	}
})
</script>
⋮----
<style scoped>
.home {
	padding: 2em;
}
</style>

================
File: views/PlaylistView.vue
================
<template>
	<div class="playlists">
		<div class="d-flex justify-content-between align-items-center">
			<b-button to="/">Back</b-button>
			<h2>{{ playlist.name }}</h2>
			<b-button @click="newRundown">New</b-button>
		</div>
		<b-list-group>
			<b-list-group-item
				v-for="rundown in rundowns"
				:key="rundown.id"
				href="#"
				:to="'/rundown/' + rundown.id"
			>
				{{ rundown.name }}
			</b-list-group-item>
		</b-list-group>
	</div>
</template>
⋮----
<h2>{{ playlist.name }}</h2>
⋮----
{{ rundown.name }}
⋮----
<script lang="ts">
import { Playlist, Rundown } from '@/background/interfaces'
import store from '@/store'
import Vue from 'vue'

export default Vue.extend({
	computed: {
		matchedId(): string {
			return this.$route.params.id
		},
		playlist(): Playlist | undefined {
			return store.state.playlists.find((p) => p.id === this.matchedId)
		},
		rundowns(): Rundown[] {
			return store.state.rundowns.filter((r) => r.playlistId === this.matchedId)
		}
	},
	methods: {
		newRundown() {
			store.dispatch('newRundown', { playlistId: this.matchedId })
		}
	}
})
</script>
⋮----
<style scoped>
.playlist {
	padding: 2em;
}
</style>

================
File: views/RundownView.vue
================
<template>
	<div class="rundown d-flex flex-column">
		<template v-if="loaded">
			<rundown-header class="" />
			<div class="body flex-grow-1 d-flex">
				<segment-list />
				<router-view class="flex-grow-1" name="rundown-left"></router-view>
				<router-view class="flex-grow-1" name="rundown-right"></router-view>
			</div>
			<rundown-footer />
		</template>
		<div v-else class="loader d-flex align-items-center justify-content-center">
			<b-spinner></b-spinner>
		</div>
	</div>
</template>
⋮----
<template v-if="loaded">
			<rundown-header class="" />
			<div class="body flex-grow-1 d-flex">
				<segment-list />
				<router-view class="flex-grow-1" name="rundown-left"></router-view>
				<router-view class="flex-grow-1" name="rundown-right"></router-view>
			</div>
			<rundown-footer />
		</template>
⋮----
<script lang="ts">
import store from '@/store'
import Vue from 'vue'
import RundownHeader from '../components/rundown/RundownHeader.vue'
import SegmentList from '../components/rundown/SegmentList.vue'
import RundownFooter from '../components/rundown/RundownFooter.vue'

export default Vue.extend({
	components: { RundownHeader, SegmentList, RundownFooter },
	data() {
		return {
			loaded: false
		}
	},
	async mounted() {
		this.loaded = false
		await store.dispatch('loadRundown', this.$route.params.id)
		this.loaded = true
	}
})
</script>
⋮----
<style scoped>
.rundown {
	height: 100%;
}
.loader {
	width: 100%;
	height: 100%;
}
.body {
	overflow: hidden;
}
.body div {
	overflow-y: auto;
}
</style>

================
File: views/SettingsView.vue
================
<template>
	<div class="settings">
		<settings />
		<piece-types />
	</div>
</template>
⋮----
<script lang="ts">
import Vue from 'vue'
import PieceTypes from '@/components/settings/PieceTypes.vue'
import Settings from '@/components/settings/AppSettings.vue'

export default Vue.extend({
	components: { PieceTypes, Settings }
})
</script>
⋮----
<style scoped>
.settings {
	padding: 0.5em;
	overflow-y: auto;
	max-height: 100%;
}
</style>

================
File: App.vue
================
<template>
	<div id="app">
		<router-view name="header"></router-view>
		<router-view></router-view>
	</div>
</template>
⋮----
<script lang="ts">
import Vue from 'vue'

const { ipcRenderer } = window

export default Vue.extend({
	name: 'App',
	methods: {
		// eslint-disable-next-line no-undef
		handleError(_: Electron.IpcRendererEvent, error: unknown) {
			// eslint-disable-next-line no-console
			console.error(error)

			let message = 'An unknown error occurred.'
			let title = 'Error'
			if (typeof error === 'string') {
				message = error
			} else if (typeof error === 'object' && error !== null && 'message' in error) {
				/* eslint-disable @typescript-eslint/no-explicit-any */
				message = (error as any).message
				if ('errorType' in error && (error as any).errorType === 'Meteor.Error') {
					title = 'Sofie Core Error'
					message = `Error when updating rundown in Sofie Core: ${message}`
				}
				/* eslint-enable @typescript-eslint/no-explicit-any */
			}
			this.$bvModal.msgBoxOk(message, { title })
		}
	},
	created() {
		ipcRenderer.on('error', this.handleError)
	},
	destroyed() {
		ipcRenderer.removeListener('error', this.handleError)
	}
})
</script>
⋮----
<style>
* {
	box-sizing: border-box;
}
#app {
	font-family: Avenir, Helvetica, Arial, sans-serif;
	-webkit-font-smoothing: antialiased;
	-moz-osx-font-smoothing: grayscale;

	background-color: #262626;
	color: #fff;

	position: absolute;
	top: 0;
	left: 0;
	bottom: 0;
	right: 0;

	overflow-y: hidden;
	overflow-x: auto;

	display: flex;
	flex-direction: column;
}
</style>

================
File: background.ts
================
import { app, protocol, BrowserWindow } from 'electron'
import { createProtocol } from 'vue-cli-plugin-electron-builder/lib'
import installExtension, { VUEJS_DEVTOOLS } from 'electron-devtools-installer'
import { ControlAPI } from './background/index'
import path from 'path'
import { initializeDefaults as initializeSettingsDefaults } from './background/api/settings'
⋮----
// Scheme must be registered before the app is ready
⋮----
async function createWindow()
⋮----
// Ensure defaults are ready before creating the browser window.
⋮----
// Create the browser window.
⋮----
// Use pluginOptions.nodeIntegration, leave this alone
// See nklayman.github.io/vue-cli-plugin-electron-builder/guide/security.html#node-integration for more info
⋮----
// const menu = Menu.buildFromTemplate([
// 	{
// 		label: 'File',
// 		submenu: [
// 			{
// 				label: 'Open',
// 				async click() {
// 					const {
// 						canceled,
// 						filePaths: [filePath]
// 					} = await dialog.showOpenDialog(win, {
// 						title: 'Open rundown',
// 						filters: [{ name: 'JSON', extensions: ['json'] }],
// 						properties: ['openFile']
// 					})
// 					if (!canceled && filePath) {
// 						try {
// 							const file = readFileSync(filePath, { encoding: 'utf-8' })
// 							const rundown = JSON.parse(file)
// 							console.log(rundown)
⋮----
// 							if (rundown.type && rundown.type === 'casparcg-playback-client-rundown') {
// 								api.loadRundown(rundown)
// 							}
// 						} catch {
// 							// ideally show the user a dialog?
// 						}
// 					}
// 				}
// 			},
// 			{
// 				label: 'Save',
// 				async click() {
// 					const { canceled, filePath } = await dialog.showSaveDialog(win, {
// 						title: 'Save rundown',
// 						filters: [{ name: 'JSON', extensions: ['json'] }],
// 						properties: ['createDirectory']
// 					})
// 					if (!canceled && filePath) {
// 						try {
// 							writeFileSync(filePath, JSON.stringify(api.getRundown()), { encoding: 'utf-8' })
// 						} catch {
// 							// ideally show the user a dialog?
// 						}
// 					}
// 				}
// 			},
// 			{ type: 'separator' },
// 			{
// 				label: 'Exit',
// 				role: 'quit',
// 				click() {
// 					app.quit()
// 				}
// 			}
// 		]
// 	}
// ])
// Menu.setApplicationMenu(menu)
⋮----
// Load the url of the dev server if in development mode
⋮----
// Load the index.html when not in development
⋮----
// Quit when all windows are closed.
⋮----
// On macOS it is common for applications and their menu bar
// to stay active until the user quits explicitly with Cmd + Q
⋮----
// On macOS it's common to re-create a window in the app when the
// dock icon is clicked and there are no other windows open.
⋮----
// This method will be called when Electron has finished
// initialization and is ready to create browser windows.
// Some APIs can only be used after this event occurs.
⋮----
// Install Vue Devtools
⋮----
// Exit cleanly on request from parent process in development mode.

================
File: main.ts
================
import Vue from 'vue'
import { BootstrapVue } from 'bootstrap-vue'
import VueRouter from 'vue-router'
import App from './App.vue'
import store, { initStore } from './store'
⋮----
// Import Bootstrap an BootstrapVue CSS files (order is important)
⋮----
import { library } from '@fortawesome/fontawesome-svg-core'
import { faTimes, faPencilAlt, faTrash } from '@fortawesome/free-solid-svg-icons'
import { FontAwesomeIcon } from '@fortawesome/vue-fontawesome'
⋮----
import { router } from './router'
⋮----
// eslint-disable-next-line vue/multi-word-component-names

================
File: preload.ts
================
import { IpcRenderer, ipcRenderer } from 'electron'
import { promises as fs } from 'fs'
import { dialog } from '@electron/remote'
⋮----
interface Window {
		ipcRenderer: IpcRenderer
		fs: typeof fs
		remoteDialog: typeof dialog
	}

================
File: shims-tsx.d.ts
================
import Vue, { VNode } from 'vue'
⋮----
// tslint:disable no-empty-interface
type Element = VNode
// tslint:disable no-empty-interface
type ElementClass = Vue
interface IntrinsicElements {
			[elem: string]: any
		}

================
File: shims-vue.d.ts
================
import Vue from 'vue'



================================================================
End of Codebase
================================================================
